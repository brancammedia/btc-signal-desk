<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BTC Signal Desk</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Outfit:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0e17; --card: #111827; --card2: #0d1320; --border: #1e293b; --border2: #334155;
  --text: #e2e8f0; --dim: #94a3b8; --muted: #64748b; --dark: #475569;
  --bull: #22c55e; --bull-dim: #166534; --bull-bg: rgba(34,197,94,0.08);
  --bear: #ef4444; --bear-dim: #991b1b; --bear-bg: rgba(239,68,68,0.08);
  --accent: #3b82f6; --accent-dim: #1d4ed8; --accent-bg: rgba(59,130,246,0.08);
  --warn: #f59e0b; --warn-bg: rgba(245,158,11,0.08);
}
*{margin:0;padding:0;box-sizing:border-box;}
html{overflow-x:hidden;}
body{background:var(--bg);color:var(--dim);font-family:'JetBrains Mono',monospace;font-size:14px;line-height:1.5;overflow-x:hidden;}
::-webkit-scrollbar{width:5px;height:5px;}
::-webkit-scrollbar-track{background:var(--bg);}
::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px;}
h1,h2,h3,h4{font-family:'Outfit',sans-serif;color:var(--text);margin:0;}

/* Layout */
.header{background:var(--card);border-bottom:1px solid var(--border);padding:12px 20px;display:flex;align-items:center;gap:12px;flex-wrap:wrap;position:sticky;top:0;z-index:100;}
.main-grid{display:grid;grid-template-columns:1fr;gap:12px;padding:12px;}
.col-left,.col-right{display:flex;flex-direction:column;gap:12px;}
@media(min-width:1100px){
  .main-grid{grid-template-columns:3fr 2fr;}
  .bottom-panel{grid-column:1/-1;}
}

/* Cards */
.card{background:var(--card);border:1px solid var(--border);border-radius:8px;overflow:hidden;}
.card-head{background:var(--card2);padding:8px 14px;font-family:'Outfit',sans-serif;font-weight:600;font-size:15px;color:var(--text);border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;cursor:pointer;user-select:none;}
.card-head:hover{background:var(--border);}
.card-body{padding:10px 14px;}

/* Tables */
table{width:100%;border-collapse:collapse;}
th{text-align:left;color:var(--muted);font-weight:500;font-size:12px;text-transform:uppercase;letter-spacing:0.5px;padding:4px 8px;border-bottom:1px solid var(--border);}
td{padding:4px 8px;border-bottom:1px solid rgba(30,41,59,0.4);font-size:13px;white-space:nowrap;}

/* Colors */
.bull{color:var(--bull);}.bear{color:var(--bear);}.warn{color:var(--warn);}.accent{color:var(--accent);}.muted{color:var(--muted);}.text{color:var(--text);}
.bull-bg{background:var(--bull-bg);}.bear-bg{background:var(--bear-bg);}.warn-bg{background:var(--warn-bg);}

/* Badges */
.badge{display:inline-block;padding:3px 10px;border-radius:4px;font-size:12px;font-weight:700;letter-spacing:0.5px;text-transform:uppercase;}
.badge-bull{background:var(--bull-bg);color:var(--bull);border:1px solid var(--bull-dim);}
.badge-bear{background:var(--bear-bg);color:var(--bear);border:1px solid var(--bear-dim);}
.badge-neutral{background:var(--accent-bg);color:var(--accent);border:1px solid var(--accent-dim);}
.badge-warn{background:var(--warn-bg);color:var(--warn);border:1px solid rgba(245,158,11,0.3);}

/* Sub-headings */
.sub-h{color:var(--accent);font-size:12px;font-weight:600;padding:8px 0 3px;text-transform:uppercase;letter-spacing:0.7px;}

/* Buttons */
.btn{background:var(--border);border:1px solid var(--border2);color:var(--dim);padding:6px 14px;border-radius:6px;cursor:pointer;font-family:inherit;font-size:13px;transition:all 0.15s;}
.btn:hover{background:var(--border2);color:var(--text);}
.btn-accent{background:var(--accent-dim);border-color:var(--accent);color:#fff;}
.btn-accent:hover{background:var(--accent);}
.btn-bull{background:var(--bull-dim);border-color:var(--bull);color:#fff;}
.btn-bear{background:var(--bear-dim);border-color:var(--bear);color:#fff;}

/* Inputs */
.input{background:var(--card2);border:1px solid var(--border);color:var(--text);padding:5px 10px;border-radius:4px;font-family:inherit;font-size:13px;width:110px;text-align:right;}
.input:focus{outline:none;border-color:var(--accent);}

/* Confluence meter */
.meter-bar{height:6px;border-radius:3px;background:var(--border);overflow:hidden;position:relative;}
.meter-fill{height:100%;border-radius:3px;transition:width 0.5s ease;}

/* Trade setup glow */
.glow-bull{box-shadow:0 0 25px rgba(34,197,94,0.15),0 0 50px rgba(34,197,94,0.05);border-color:var(--bull-dim)!important;}
.glow-bear{box-shadow:0 0 25px rgba(239,68,68,0.15),0 0 50px rgba(239,68,68,0.05);border-color:var(--bear-dim)!important;}

/* Session indicator */
.session-dot{width:6px;height:6px;border-radius:50%;display:inline-block;flex-shrink:0;}
.session-pill{display:flex;align-items:center;gap:5px;background:var(--card2);border:1px solid var(--border);border-radius:5px;padding:3px 8px;font-size:10px;white-space:nowrap;}
.session-pill .s-name{font-weight:600;min-width:28px;}
.session-pill .s-timer{font-family:'JetBrains Mono',monospace;font-size:9px;color:var(--muted);letter-spacing:-0.3px;}

/* Tabs */
.tabs{display:flex;gap:2px;padding:4px;background:var(--card2);border-radius:6px;margin-bottom:8px;}
.tab{padding:6px 14px;border-radius:4px;cursor:pointer;font-size:13px;font-weight:500;color:var(--muted);transition:all 0.15s;text-align:center;flex:1;}
.tab:hover{color:var(--dim);background:rgba(59,130,246,0.05);}
.tab.active{background:var(--accent-dim);color:#fff;}

/* Tooltip */
.tip{position:relative;cursor:help;border-bottom:1px dotted var(--muted);}
.tip .tip-text{display:none;position:absolute;bottom:120%;left:50%;transform:translateX(-50%);background:var(--card);border:1px solid var(--border2);color:var(--dim);padding:6px 10px;border-radius:6px;font-size:12px;white-space:normal;width:220px;z-index:50;line-height:1.4;box-shadow:0 4px 12px rgba(0,0,0,0.4);}
.tip:hover .tip-text{display:block;}

/* Info tip (?) icon */
.info-tip{display:inline-flex;align-items:center;justify-content:center;width:16px;height:16px;border-radius:50%;background:var(--border);color:var(--muted);font-size:10px;font-weight:700;font-family:'JetBrains Mono',monospace;cursor:help;margin-left:5px;flex-shrink:0;transition:all 0.15s;line-height:1;vertical-align:middle;user-select:none;}
.info-tip:hover{background:var(--accent-dim);color:#fff;}

/* Fixed-position bubble rendered via portal */
.info-bubble-fixed{position:fixed;background:var(--card2);border:1px solid var(--border2);color:var(--dim);padding:10px 12px;border-radius:8px;font-size:12px;font-weight:400;white-space:normal;width:280px;z-index:9999;line-height:1.5;box-shadow:0 8px 24px rgba(0,0,0,0.6);pointer-events:none;font-family:'JetBrains Mono',monospace;}
.info-bubble-fixed::after{content:'';position:absolute;left:var(--arrow,50%);transform:translateX(-50%);border:6px solid transparent;}
.info-bubble-fixed.above::after{top:100%;border-top-color:var(--border2);}
.info-bubble-fixed.below::after{bottom:100%;border-bottom-color:var(--border2);}
.info-bubble-fixed.positioning{opacity:0;}

/* RR bar */
.rr-bar{display:flex;height:22px;border-radius:4px;overflow:hidden;font-size:11px;font-weight:600;line-height:22px;text-align:center;}
.rr-sl{background:var(--bear-dim);color:var(--bear);}
.rr-tp{background:var(--bull-dim);color:var(--bull);}

/* Animations */
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.55}}
@keyframes fadeIn{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:translateY(0)}}
.pulse{animation:pulse 1.5s infinite;}
.fade-in{animation:fadeIn .3s ease-out;}

/* Loading */
.loading{text-align:center;padding:40px;color:var(--muted);}
.error-box{color:var(--bear);background:var(--bear-bg);border:1px solid var(--bear-dim);padding:10px 16px;margin:12px;border-radius:8px;font-size:13px;}

/* Journal */
.journal-stats{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:10px;}
.journal-stat{background:var(--card2);border:1px solid var(--border);border-radius:6px;padding:8px 14px;min-width:100px;text-align:center;}
.journal-stat .val{font-size:22px;font-weight:700;color:var(--text);font-family:'JetBrains Mono',monospace;}
.journal-stat .lbl{font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px;margin-top:2px;}
.outcome-btn{padding:3px 10px;border-radius:4px;font-size:12px;font-weight:600;cursor:pointer;border:1px solid;transition:all .15s;font-family:inherit;}
.outcome-btn:hover{filter:brightness(1.3);}
.outcome-pending{background:var(--accent-bg);color:var(--accent);border-color:var(--accent-dim);}
.outcome-win{background:var(--bull-bg);color:var(--bull);border-color:var(--bull-dim);}
.outcome-loss{background:var(--bear-bg);color:var(--bear);border-color:var(--bear-dim);}
.journal-import{display:none;}
.journal-toolbar{display:flex;gap:6px;flex-wrap:wrap;align-items:center;}

/* Footer */
.footer{background:var(--card);border-top:1px solid var(--border);padding:12px 20px;font-size:12px;color:var(--muted);line-height:1.6;}

/* Responsive */
@media(max-width:768px){
  .header{padding:8px 10px;font-size:13px;gap:6px;}
  .session-pill{padding:2px 6px;font-size:9px;}
  .session-pill .s-name{min-width:auto;font-size:9px;}
  .session-pill .s-timer{font-size:8px;}
  .main-grid{display:flex!important;flex-direction:column;padding:8px;gap:8px;}
  .col-left,.col-right{display:contents!important;}
  .card-body{padding:8px 10px;}
  td,th{padding:3px 6px;font-size:11px;}
  td{white-space:normal;word-break:break-word;}
  table{table-layout:auto;}
  .card{overflow-x:auto;max-width:100vw;}
  .tabs{overflow-x:auto;flex-wrap:nowrap;-webkit-overflow-scrolling:touch;}
  .tab{flex:0 0 auto;padding:6px 10px;font-size:12px;}
  .journal-stats{gap:6px;}
  .journal-stat{min-width:70px;padding:6px 8px;}
  .journal-stat .val{font-size:16px;}
  .info-bubble-fixed{width:220px;font-size:11px;}
  .input{width:80px;font-size:12px;}

  /* Module ordering: 1=Chart, 2=Summary, 3=Trade Setup, 4=Entry Timing, rest after */
  .m-chart{order:1!important;}
  .m-summary{order:2!important;}
  .m-setup{order:3!important;}
  .m-entry{order:4!important;}
  .m-confluence{order:5!important;}
  .m-tf{order:6!important;}
  .m-factors{order:7!important;}
  .m-history{order:8!important;}
  .m-tvChart{order:9!important;}
  .m-journal{order:10!important;}
  .m-levels{order:11!important;}
  .m-siglog{order:12!important;}
}
@media(max-width:480px){
  .header h1{font-size:16px!important;}
  .badge{font-size:10px;padding:2px 6px;}
  .card-head{font-size:13px;padding:6px 10px;}
  .sub-h{font-size:11px;}
}
.btt{position:fixed;bottom:24px;right:24px;z-index:9999;width:44px;height:44px;border-radius:50%;background:var(--card);border:1px solid var(--border);color:var(--text);font-size:20px;cursor:pointer;opacity:0;pointer-events:none;transition:opacity .25s;display:flex;align-items:center;justify-content:center;box-shadow:0 2px 8px rgba(0,0,0,.4);}
.btt.vis{opacity:.7;pointer-events:auto;}
.btt:hover{opacity:1;background:var(--accent);color:#fff;}
@media(max-width:768px){.btt{width:36px;height:36px;font-size:16px;bottom:16px;right:16px;}}
</style>
</head>
<body>
<div id="root"></div>
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://unpkg.com/lightweight-charts@4/dist/lightweight-charts.standalone.production.js"></script>
<script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
<script type="text/babel">
const {useState,useEffect,useRef,useCallback,useMemo} = React;

// ═══════════════════════════════════════════════════════════════
// CONSTANTS
// ═══════════════════════════════════════════════════════════════
const API_ENDPOINTS = [
  'https://api.binance.us/api/v3',
  'https://api1.binance.com/api/v3',
  'https://api.binance.com/api/v3',
];
const WS_ENDPOINTS = [
  'wss://stream.binance.us:9443/ws/btcusdt@kline_1m',
  'wss://stream.binance.com:9443/ws/btcusdt@kline_1m',
];
const TIMEFRAMES = ['15m','1h','4h','1d','1w'];
const TF_LABELS  = {'15m':'15m','1h':'1H','4h':'4H','1d':'Daily','1w':'Weekly'};
const TF_WEIGHTS = {'1w':5,'1d':4,'4h':3,'1h':2,'15m':1};
const CANDLE_LIMIT = 200;
const REFRESH_MS = 60000;
const FETCH_TIMEOUT = 10000;

// ═══════════════════════════════════════════════════════════════
// DATA SERVICE
// ═══════════════════════════════════════════════════════════════
const DataService = {
  _baseUrl: null,
  _fetchWithTimeout(url, ms = FETCH_TIMEOUT) {
    const c = new AbortController();
    const t = setTimeout(() => c.abort(), ms);
    return fetch(url, {signal:c.signal}).finally(() => clearTimeout(t));
  },
  async _findEndpoint(cb) {
    for (const base of API_ENDPOINTS) {
      try {
        cb && cb(`Trying ${base}...`);
        const r = await this._fetchWithTimeout(`${base}/ping`);
        if (r.ok) { this._baseUrl = base; cb && cb(`Connected: ${base}`); return; }
      } catch {}
    }
    throw new Error('All Binance API endpoints unreachable.');
  },
  async _fetch(url, retries = 3) {
    for (let i = 0; i < retries; i++) {
      try {
        const r = await this._fetchWithTimeout(url);
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return await r.json();
      } catch (e) { if (i === retries - 1) throw e; await new Promise(r => setTimeout(r, 1000 * 2 ** i)); }
    }
  },
  _parse(raw) {
    return raw.map(k => ({time:k[0],open:+k[1],high:+k[2],low:+k[3],close:+k[4],volume:+k[5]}));
  },
  async fetchAll(cb) {
    if (!this._baseUrl) await this._findEndpoint(cb);
    cb && cb('Fetching candles...');
    const candles = {};
    const errs = [];
    const res = await Promise.allSettled(TIMEFRAMES.map(async tf => {
      const raw = await this._fetch(`${this._baseUrl}/klines?symbol=BTCUSDT&interval=${tf}&limit=${CANDLE_LIMIT}`);
      candles[tf] = this._parse(raw);
    }));
    res.forEach((r, i) => { if (r.status === 'rejected') errs.push(TIMEFRAMES[i]); });
    if (errs.length === TIMEFRAMES.length) throw new Error('All fetches failed');
    cb && cb('Fetching ticker...');
    const ticker = await this._fetch(`${this._baseUrl}/ticker/24hr?symbol=BTCUSDT`);
    return {candles, ticker, errs};
  },
  getWsUrl() { return this._baseUrl?.includes('binance.us') ? WS_ENDPOINTS[0] : WS_ENDPOINTS[1]; },

  // Paginated historical fetch — goes back to startMs, 1000 candles per request
  _histCache: {},
  async fetchHistorical(tf, startMs) {
    const key = tf + '_' + startMs;
    if (this._histCache[key]) return this._histCache[key];
    if (!this._baseUrl) await this._findEndpoint();
    const all = [];
    let cursor = startMs;
    const now = Date.now();
    while (cursor < now) {
      const raw = await this._fetch(`${this._baseUrl}/klines?symbol=BTCUSDT&interval=${tf}&startTime=${cursor}&limit=1000`);
      if (!raw || !raw.length) break;
      const parsed = this._parse(raw);
      all.push(...parsed);
      // next batch starts after the last candle's open time
      const lastTime = raw[raw.length - 1][0];
      if (lastTime <= cursor) break; // safety
      cursor = lastTime + 1;
      if (raw.length < 1000) break; // last page
    }
    this._histCache[key] = all;
    return all;
  }
};

// ═══════════════════════════════════════════════════════════════
// INDICATOR ENGINE
// ═══════════════════════════════════════════════════════════════
const Ind = {
  sma(d, p) {
    const o = Array(d.length).fill(null);
    for (let i = p - 1; i < d.length; i++) { let s = 0; for (let j = i - p + 1; j <= i; j++) s += d[j]; o[i] = s / p; }
    return o;
  },
  ema(d, p) {
    const k = 2 / (p + 1), o = Array(d.length).fill(null);
    let s = 0; for (let i = 0; i < p; i++) s += d[i]; o[p - 1] = s / p;
    for (let i = p; i < d.length; i++) o[i] = d[i] * k + o[i - 1] * (1 - k);
    return o;
  },
  rsi(c, p = 14) {
    const o = Array(c.length).fill(null);
    if (c.length < p + 1) return o;
    let gS = 0, lS = 0;
    for (let i = 1; i <= p; i++) { const d = c[i] - c[i - 1]; d > 0 ? gS += d : lS -= d; }
    let aG = gS / p, aL = lS / p;
    o[p] = aL === 0 ? 100 : 100 - 100 / (1 + aG / aL);
    for (let i = p + 1; i < c.length; i++) {
      const d = c[i] - c[i - 1];
      aG = (aG * (p - 1) + (d > 0 ? d : 0)) / p;
      aL = (aL * (p - 1) + (d < 0 ? -d : 0)) / p;
      o[i] = aL === 0 ? 100 : 100 - 100 / (1 + aG / aL);
    }
    return o;
  },
  macd(c, f = 12, s = 26, g = 9) {
    const eF = this.ema(c, f), eS = this.ema(c, s);
    const line = c.map((_, i) => eF[i] != null && eS[i] != null ? eF[i] - eS[i] : null);
    const fv = line.findIndex(v => v != null);
    const mv = line.slice(fv).map(v => v ?? 0);
    const sr = this.ema(mv, g);
    const signal = Array(fv).fill(null).concat(sr);
    const hist = c.map((_, i) => line[i] != null && signal[i] != null ? line[i] - signal[i] : null);
    return {line, signal, hist};
  },
  bollinger(c, p = 20, m = 2) {
    const mid = this.sma(c, p), u = Array(c.length).fill(null), l = Array(c.length).fill(null), bw = Array(c.length).fill(null);
    for (let i = p - 1; i < c.length; i++) {
      let sq = 0; for (let j = i - p + 1; j <= i; j++) sq += (c[j] - mid[i]) ** 2;
      const sd = Math.sqrt(sq / p);
      u[i] = mid[i] + m * sd; l[i] = mid[i] - m * sd;
      bw[i] = mid[i] ? ((u[i] - l[i]) / mid[i]) * 100 : null;
    }
    return {upper: u, middle: mid, lower: l, bw};
  },
  atr(candles, p = 14) {
    const tr = candles.map((c, i) => i === 0 ? c.high - c.low : Math.max(c.high - c.low, Math.abs(c.high - candles[i-1].close), Math.abs(c.low - candles[i-1].close)));
    const o = Array(candles.length).fill(null);
    let s = 0; for (let i = 0; i < p; i++) s += tr[i]; o[p - 1] = s / p;
    for (let i = p; i < tr.length; i++) o[i] = (o[i - 1] * (p - 1) + tr[i]) / p;
    return o;
  },
  adx(candles, p = 14) {
    const len = candles.length, pDI = Array(len).fill(null), mDI = Array(len).fill(null), adxO = Array(len).fill(null);
    if (len < p * 2 + 1) return {adx: adxO, pDI, mDI};
    const tr = [], pd = [], md = [];
    for (let i = 1; i < len; i++) {
      const h = candles[i].high, l = candles[i].low, pH = candles[i-1].high, pL = candles[i-1].low, pC = candles[i-1].close;
      tr.push(Math.max(h - l, Math.abs(h - pC), Math.abs(l - pC)));
      const u = h - pH, d = pL - l;
      pd.push(u > d && u > 0 ? u : 0);
      md.push(d > u && d > 0 ? d : 0);
    }
    let sT = 0, sP = 0, sM = 0;
    for (let i = 0; i < p; i++) { sT += tr[i]; sP += pd[i]; sM += md[i]; }
    const setDI = idx => { pDI[idx] = sT ? (sP / sT) * 100 : 0; mDI[idx] = sT ? (sM / sT) * 100 : 0; };
    setDI(p);
    const dx = [], dxV = (a, b) => (a + b) ? (Math.abs(a - b) / (a + b)) * 100 : 0;
    dx.push(dxV(pDI[p], mDI[p]));
    for (let i = p; i < tr.length; i++) {
      sT = sT - sT / p + tr[i]; sP = sP - sP / p + pd[i]; sM = sM - sM / p + md[i];
      setDI(i + 1); dx.push(dxV(pDI[i + 1], mDI[i + 1]));
    }
    if (dx.length >= p) {
      let aS = 0; for (let i = 0; i < p; i++) aS += dx[i]; let aV = aS / p;
      adxO[p * 2] = aV;
      for (let i = p; i < dx.length; i++) { aV = (aV * (p - 1) + dx[i]) / p; adxO[p + i] = aV; }
    }
    return {adx: adxO, pDI, mDI};
  },
  stochRSI(c, rP = 14, sP = 14, kS = 3, dS = 3) {
    const rv = this.rsi(c, rP), out = {k: Array(c.length).fill(null), d: Array(c.length).fill(null)};
    const raw = Array(c.length).fill(null);
    for (let i = 0; i < c.length; i++) {
      if (rv[i] == null) continue;
      let hi = -Infinity, lo = Infinity, n = 0;
      for (let j = i; j >= 0 && n < sP; j--) { if (rv[j] == null) continue; hi = Math.max(hi, rv[j]); lo = Math.min(lo, rv[j]); n++; }
      if (n === sP && hi !== lo) raw[i] = ((rv[i] - lo) / (hi - lo)) * 100;
    }
    const vK = []; for (let i = 0; i < raw.length; i++) if (raw[i] != null) vK.push({i, v: raw[i]});
    for (let i = kS - 1; i < vK.length; i++) { let s = 0; for (let j = i - kS + 1; j <= i; j++) s += vK[j].v; out.k[vK[i].i] = s / kS; }
    const vD = []; for (let i = 0; i < out.k.length; i++) if (out.k[i] != null) vD.push({i, v: out.k[i]});
    for (let i = dS - 1; i < vD.length; i++) { let s = 0; for (let j = i - dS + 1; j <= i; j++) s += vD[j].v; out.d[vD[i].i] = s / dS; }
    return out;
  },
  ichimoku(candles, tP = 9, kP = 26, bP = 52, disp = 26) {
    const len = candles.length, hs = candles.map(c => c.high), ls = candles.map(c => c.low);
    const mid = (a1, a2, idx, p) => {
      if (idx < p - 1) return null;
      let hi = -Infinity, lo = Infinity;
      for (let i = idx - p + 1; i <= idx; i++) { hi = Math.max(hi, a1[i]); lo = Math.min(lo, a2[i]); }
      return (hi + lo) / 2;
    };
    const tenkan = candles.map((_, i) => mid(hs, ls, i, tP));
    const kijun = candles.map((_, i) => mid(hs, ls, i, kP));
    const sA = Array(len + disp).fill(null), sB = Array(len + disp).fill(null);
    for (let i = 0; i < len; i++) {
      if (tenkan[i] != null && kijun[i] != null) sA[i + disp] = (tenkan[i] + kijun[i]) / 2;
      const v = mid(hs, ls, i, bP); if (v != null) sB[i + disp] = v;
    }
    const chikou = Array(len).fill(null);
    for (let i = disp; i < len; i++) chikou[i - disp] = candles[i].close;
    return {tenkan, kijun, sA: sA.slice(0, len), sB: sB.slice(0, len), chikou};
  },
  vwap(candles) {
    const o = []; let cTPV = 0, cV = 0;
    for (const c of candles) { const tp = (c.high + c.low + c.close) / 3; cTPV += tp * c.volume; cV += c.volume; o.push(cV ? cTPV / cV : null); }
    return o;
  },
  obv(candles) {
    const o = [0];
    for (let i = 1; i < candles.length; i++) o.push(o[i-1] + (candles[i].close > candles[i-1].close ? candles[i].volume : candles[i].close < candles[i-1].close ? -candles[i].volume : 0));
    return o;
  },
  pivotPoints(c) {
    const PP = (c.high + c.low + c.close) / 3;
    return {pp:PP, r1:2*PP-c.low, s1:2*PP-c.high, r2:PP+(c.high-c.low), s2:PP-(c.high-c.low), r3:c.high+2*(PP-c.low), s3:c.low-2*(c.high-PP)};
  },
  fibRetrace(hi, lo) {
    const d = hi - lo;
    return [0,.236,.382,.5,.618,.786,1].map(r => ({r, p: hi - d * r}));
  },
  fibExtend(lo, hi, retLo) {
    const d = hi - lo;
    return [1,1.272,1.618,2].map(r => ({r, p: retLo + d * r}));
  },
  computeAll(candles) {
    const c = candles.map(x => x.close), L = candles.length - 1, price = c[L];
    const ema9=this.ema(c,9),ema21=this.ema(c,21),ema50=this.ema(c,50),ema100=this.ema(c,100),ema200=this.ema(c,200);
    const sma50=this.sma(c,50),sma200=this.sma(c,200);
    const rsiA=this.rsi(c,14),macdD=this.macd(c),stochD=this.stochRSI(c),adxD=this.adx(candles,14);
    const bbD=this.bollinger(c),atrA=this.atr(candles,14);
    const obvA=this.obv(candles),volSMA=this.sma(candles.map(x=>x.volume),20);
    const ichiD=this.ichimoku(candles), vwapA=this.vwap(candles);
    const pivC=candles.length>=2?candles[L-1]:candles[L], pivots=this.pivotPoints(pivC);
    const rHi=Math.max(...candles.slice(-50).map(x=>x.high)),rLo=Math.min(...candles.slice(-50).map(x=>x.low));
    const fibs=this.fibRetrace(rHi,rLo);
    const fibExts=this.fibExtend(rLo,rHi,rLo);
    const atrV=atrA[L],atrPct=atrV!=null?(atrV/price)*100:null;
    const curVol=candles[L].volume,avgVol=volSMA[L],volRatio=avgVol&&avgVol>0?curVol/avgVol:null;
    // SMA cross
    let cross='None';
    if(sma50[L]!=null&&sma200[L]!=null&&sma50[L-1]!=null&&sma200[L-1]!=null){
      if(sma50[L-1]<=sma200[L-1]&&sma50[L]>sma200[L])cross='Golden Cross';
      else if(sma50[L-1]>=sma200[L-1]&&sma50[L]<sma200[L])cross='Death Cross';
      else cross=sma50[L]>sma200[L]?'Bullish (50>200)':'Bearish (50<200)';
    }
    // Ichimoku summary
    const cT=ichiD.sA[L]!=null&&ichiD.sB[L]!=null?Math.max(ichiD.sA[L],ichiD.sB[L]):null;
    const cB=ichiD.sA[L]!=null&&ichiD.sB[L]!=null?Math.min(ichiD.sA[L],ichiD.sB[L]):null;
    const iPos=cT==null?'N/A':price>cT?'Above Cloud':price<cB?'Below Cloud':'Inside Cloud';
    const tkX=ichiD.tenkan[L]!=null&&ichiD.kijun[L]!=null?(ichiD.tenkan[L]>ichiD.kijun[L]?'Bullish':'Bearish'):'N/A';
    const bbSq=bbD.bw[L]!=null&&bbD.bw[L]<4;
    // BB width percentile for volatility regime
    const bwArr=bbD.bw.filter(v=>v!=null).slice(-50);
    let bwPctile=null;
    if(bwArr.length>=10&&bbD.bw[L]!=null){
      const sorted=[...bwArr].sort((a,b)=>a-b);
      bwPctile=(sorted.indexOf(sorted.reduce((a,b)=>Math.abs(b-bbD.bw[L])<Math.abs(a-bbD.bw[L])?b:a))/sorted.length)*100;
    }
    let volRegime='Normal';
    if(bwPctile!=null){if(bwPctile<20)volRegime='Low Vol Squeeze';else if(bwPctile<50)volRegime='Normal';else if(bwPctile<80)volRegime='Elevated';else volRegime='Extreme Expansion';}

    return {
      price, candles, rsiArr: rsiA, obvArr: obvA,
      ema:{9:ema9[L],21:ema21[L],50:ema50[L],100:ema100[L],200:ema200[L]},
      sma:{50:sma50[L],200:sma200[L]}, cross,
      ichimoku:{tenkan:ichiD.tenkan[L],kijun:ichiD.kijun[L],sA:ichiD.sA[L],sB:ichiD.sB[L],chikou:ichiD.chikou[L],pos:iPos,tkX,cloudTop:cT,cloudBot:cB},
      vwap:vwapA[L],
      rsi:rsiA[L],
      macd:{line:macdD.line[L],signal:macdD.signal[L],hist:macdD.hist[L],xover:macdD.line[L]!=null&&macdD.signal[L]!=null?(macdD.line[L]>macdD.signal[L]?'Bullish':'Bearish'):'N/A'},
      stochRSI:{k:stochD.k[L],d:stochD.d[L]},
      adx:{val:adxD.adx[L],pDI:adxD.pDI[L],mDI:adxD.mDI[L]},
      bb:{upper:bbD.upper[L],mid:bbD.middle[L],lower:bbD.lower[L],bw:bbD.bw[L],squeeze:bbSq},
      atr:{val:atrV,pct:atrPct},
      obv:obvA[L],obvPrev:obvA[L-1],volume:curVol,volAvg:avgVol,volRatio,
      pivots,fibs,fibExts,
      volRegime, bwPctile,
      recentHigh:rHi, recentLow:rLo,
    };
  }
};

// ═══════════════════════════════════════════════════════════════
// SMC ENGINE (Smart Money Concepts)
// ═══════════════════════════════════════════════════════════════
const SMC = {
  findSwings(candles, look = 5) {
    const half = Math.floor(look / 2), highs = [], lows = [];
    for (let i = half; i < candles.length - half; i++) {
      let isH = true, isL = true;
      for (let j = i - half; j <= i + half; j++) {
        if (j === i) continue;
        if (candles[j].high >= candles[i].high) isH = false;
        if (candles[j].low <= candles[i].low) isL = false;
      }
      if (isH) highs.push({idx: i, price: candles[i].high, time: candles[i].time});
      if (isL) lows.push({idx: i, price: candles[i].low, time: candles[i].time});
    }
    return {highs, lows};
  },
  detectBOS(candles, swings) {
    const events = [];
    const {highs, lows} = swings;
    for (let i = 1; i < candles.length; i++) {
      const rH = [...highs].reverse().find(h => h.idx < i);
      const rL = [...lows].reverse().find(l => l.idx < i);
      if (rH && candles[i].close > rH.price && !(candles[i-1].close > rH.price))
        events.push({type:'bullish',price:rH.price,idx:i,swIdx:rH.idx,time:candles[i].time});
      if (rL && candles[i].close < rL.price && !(candles[i-1].close < rL.price))
        events.push({type:'bearish',price:rL.price,idx:i,swIdx:rL.idx,time:candles[i].time});
    }
    return events;
  },
  detectCHOCH(bos) {
    const out = []; let prev = null;
    for (const b of bos) { if (prev && b.type !== prev) out.push({...b, from: prev}); prev = b.type; }
    return out;
  },
  findFVGs(candles) {
    const fvgs = [];
    for (let i = 2; i < candles.length; i++) {
      if (candles[i-2].high < candles[i].low)
        fvgs.push({type:'bullish',top:candles[i].low,bot:candles[i-2].high,idx:i-1,time:candles[i-1].time,filled:false});
      if (candles[i-2].low > candles[i].high)
        fvgs.push({type:'bearish',top:candles[i-2].low,bot:candles[i].high,idx:i-1,time:candles[i-1].time,filled:false});
    }
    for (const f of fvgs) {
      for (let i = f.idx + 2; i < candles.length; i++) {
        if (f.type === 'bullish' && candles[i].low <= f.bot) { f.filled = true; break; }
        if (f.type === 'bearish' && candles[i].high >= f.top) { f.filled = true; break; }
      }
    }
    return fvgs;
  },
  findOrderBlocks(candles) {
    const obs = [], bodies = candles.map(c => Math.abs(c.close - c.open));
    const avg = bodies.reduce((a, b) => a + b, 0) / bodies.length;
    for (let i = 1; i < candles.length; i++) {
      if (bodies[i] >= 2 * avg) {
        const bull = candles[i].close > candles[i].open;
        for (let j = i - 1; j >= Math.max(0, i - 5); j--) {
          const opp = bull ? candles[j].close < candles[j].open : candles[j].close > candles[j].open;
          if (opp) { obs.push({type:bull?'bullish':'bearish',high:candles[j].high,low:candles[j].low,idx:j,time:candles[j].time,dIdx:i}); break; }
        }
      }
    }
    return obs;
  },
  findLiquidity(swings) {
    const levels = [], th = 0.001;
    const check = (arr, type) => {
      for (let i = 0; i < arr.length; i++) for (let j = i + 1; j < arr.length; j++) {
        const d = Math.abs(arr[i].price - arr[j].price) / arr[i].price;
        if (d <= th) {
          const avg = (arr[i].price + arr[j].price) / 2;
          if (!levels.find(l => l.type === type && Math.abs(l.price - avg) / avg < th))
            levels.push({type, price: avg});
        }
      }
    };
    check(swings.highs, 'equal_highs');
    check(swings.lows, 'equal_lows');
    return levels;
  },
  findSR(swings, price) {
    const levels = [];
    for (const h of swings.highs.slice(-10)) levels.push({price:h.price,type:'resistance',src:'Swing High'});
    for (const l of swings.lows.slice(-10)) levels.push({price:l.price,type:'support',src:'Swing Low'});
    const base = Math.floor(price / 5000) * 5000;
    for (let p = base - 15000; p <= base + 20000; p += 5000)
      if (p > 0) levels.push({price:p,type:p>price?'resistance':'support',src:'Round Number'});
    levels.sort((a, b) => Math.abs(a.price - price) - Math.abs(b.price - price));
    return levels.slice(0, 15);
  },
  // Divergence detection
  findDivergences(candles, rsiArr, obvArr) {
    const swings = this.findSwings(candles, 5);
    const divs = [];
    const {highs, lows} = swings;
    // RSI divergences on recent swings
    if (lows.length >= 2) {
      const [a, b] = lows.slice(-2);
      const rA = rsiArr[a.idx], rB = rsiArr[b.idx];
      if (rA != null && rB != null) {
        if (b.price < a.price && rB > rA) divs.push({type:'Regular Bullish',ind:'RSI',desc:'Price lower low, RSI higher low'});
        if (b.price > a.price && rB < rA) divs.push({type:'Hidden Bullish',ind:'RSI',desc:'Price higher low, RSI lower low'});
      }
    }
    if (highs.length >= 2) {
      const [a, b] = highs.slice(-2);
      const rA = rsiArr[a.idx], rB = rsiArr[b.idx];
      if (rA != null && rB != null) {
        if (b.price > a.price && rB < rA) divs.push({type:'Regular Bearish',ind:'RSI',desc:'Price higher high, RSI lower high'});
        if (b.price < a.price && rB > rA) divs.push({type:'Hidden Bearish',ind:'RSI',desc:'Price lower high, RSI higher high'});
      }
    }
    // OBV divergences
    if (lows.length >= 2) {
      const [a, b] = lows.slice(-2);
      const oA = obvArr[a.idx], oB = obvArr[b.idx];
      if (oA != null && oB != null) {
        if (b.price < a.price && oB > oA) divs.push({type:'Regular Bullish',ind:'OBV',desc:'Price lower low, OBV higher low'});
      }
    }
    if (highs.length >= 2) {
      const [a, b] = highs.slice(-2);
      const oA = obvArr[a.idx], oB = obvArr[b.idx];
      if (oA != null && oB != null) {
        if (b.price > a.price && oB < oA) divs.push({type:'Regular Bearish',ind:'OBV',desc:'Price higher high, OBV lower high'});
      }
    }
    return divs;
  },
  computeAll(candles, rsiArr, obvArr) {
    const swings = this.findSwings(candles, 5);
    const bos = this.detectBOS(candles, swings);
    const choch = this.detectCHOCH(bos);
    const fvgs = this.findFVGs(candles);
    const obs = this.findOrderBlocks(candles);
    const liq = this.findLiquidity(swings);
    const sr = this.findSR(swings, candles[candles.length - 1].close);
    const divs = this.findDivergences(candles, rsiArr, obvArr);
    const lastBOS = bos.length ? bos[bos.length - 1] : null;
    const lastCHOCH = choch.length ? choch[choch.length - 1] : null;
    const unfilled = fvgs.filter(f => !f.filled);
    return {
      swings, bos: bos.slice(-5), choch: choch.slice(-3),
      fvgs: unfilled.slice(-8), allFvgs: fvgs, obs: obs.slice(-8),
      liq, sr, divs,
      structure: lastBOS ? lastBOS.type : 'undefined',
      lastBOS, lastCHOCH,
      stats: {swH:swings.highs.length,swL:swings.lows.length,bosN:bos.length,fvgN:fvgs.length,unfN:unfilled.length,obN:obs.length}
    };
  }
};

// ═══════════════════════════════════════════════════════════════
// CONFLUENCE SCORER
// ═══════════════════════════════════════════════════════════════
const Confluence = {
  scoreTF(ind, smc) {
    let score = 0;
    const factors = [];
    const add = (pts, label) => { score += pts; factors.push({pts, label}); };
    // Price vs EMAs (+/-10 each)
    if (ind.ema[9] != null) add(ind.price > ind.ema[9] ? 10 : -10, `Price ${ind.price > ind.ema[9] ? '>' : '<'} EMA9`);
    if (ind.ema[21] != null) add(ind.price > ind.ema[21] ? 10 : -10, `Price ${ind.price > ind.ema[21] ? '>' : '<'} EMA21`);
    if (ind.ema[50] != null) add(ind.price > ind.ema[50] ? 10 : -10, `Price ${ind.price > ind.ema[50] ? '>' : '<'} EMA50`);
    if (ind.ema[100] != null) add(ind.price > ind.ema[100] ? 10 : -10, `Price ${ind.price > ind.ema[100] ? '>' : '<'} EMA100`);
    if (ind.ema[200] != null) add(ind.price > ind.ema[200] ? 10 : -10, `Price ${ind.price > ind.ema[200] ? '>' : '<'} EMA200`);
    // RSI (+/-15)
    if (ind.rsi != null) {
      if (ind.rsi > 70) add(-15, `RSI overbought (${ind.rsi.toFixed(0)})`);
      else if (ind.rsi < 30) add(15, `RSI oversold (${ind.rsi.toFixed(0)})`);
      else if (ind.rsi > 55) add(5, `RSI bullish (${ind.rsi.toFixed(0)})`);
      else if (ind.rsi < 45) add(-5, `RSI bearish (${ind.rsi.toFixed(0)})`);
    }
    // Divergences
    if (smc.divs) {
      for (const d of smc.divs) {
        if (d.type.includes('Bullish')) add(8, `${d.type} divergence (${d.ind})`);
        else add(-8, `${d.type} divergence (${d.ind})`);
      }
    }
    // MACD (+/-10)
    if (ind.macd.xover === 'Bullish') add(10, 'MACD bullish crossover');
    else if (ind.macd.xover === 'Bearish') add(-10, 'MACD bearish crossover');
    if (ind.macd.hist != null) {
      if (ind.macd.hist > 0) add(3, 'MACD histogram positive');
      else add(-3, 'MACD histogram negative');
    }
    // Ichimoku (+/-15)
    if (ind.ichimoku.pos === 'Above Cloud') add(10, 'Price above Ichimoku cloud');
    else if (ind.ichimoku.pos === 'Below Cloud') add(-10, 'Price below Ichimoku cloud');
    if (ind.ichimoku.tkX === 'Bullish') add(5, 'Ichimoku TK bullish');
    else if (ind.ichimoku.tkX === 'Bearish') add(-5, 'Ichimoku TK bearish');
    // Market structure BOS/CHOCH (+/-20)
    if (smc.structure === 'bullish') add(15, 'Bullish market structure');
    else if (smc.structure === 'bearish') add(-15, 'Bearish market structure');
    if (smc.lastCHOCH) {
      if (smc.lastCHOCH.type === 'bullish') add(5, 'Recent bullish CHOCH');
      else add(-5, 'Recent bearish CHOCH');
    }
    // OBV (+/-10)
    if (ind.obv != null && ind.obvPrev != null) {
      add(ind.obv > ind.obvPrev ? 10 : -10, `OBV ${ind.obv > ind.obvPrev ? 'rising' : 'falling'}`);
    }
    // ADX multiplier
    let adxMult = 1;
    if (ind.adx.val != null) {
      if (ind.adx.val < 20) adxMult = 0.5;
      else if (ind.adx.val > 40) adxMult = 1.5;
    }
    score = Math.max(-100, Math.min(100, Math.round(score * adxMult)));
    return {score, factors, adxMult};
  },
  composite(tfScores) {
    let wSum = 0, wTotal = 0;
    const breakdown = {};
    for (const tf of TIMEFRAMES) {
      if (!tfScores[tf]) continue;
      const w = TF_WEIGHTS[tf];
      wSum += tfScores[tf].score * w;
      wTotal += w;
      breakdown[tf] = {score: tfScores[tf].score, weight: w, weighted: tfScores[tf].score * w};
    }
    const score = wTotal ? Math.round(wSum / wTotal) : 0;
    let signal = 'NEUTRAL';
    if (score >= 60) signal = 'STRONG LONG';
    else if (score >= 20) signal = 'LONG';
    else if (score <= -60) signal = 'STRONG SHORT';
    else if (score <= -20) signal = 'SHORT';
    return {score, signal, breakdown};
  }
};

// ═══════════════════════════════════════════════════════════════
// TRADE SETUP GENERATOR
// ═══════════════════════════════════════════════════════════════
const TradeGen = {
  generate(direction, allInd, allSmc, composite, tradeCapital, riskAmt, userLev = 1) {
    // Use 4H as primary timeframe for setup, with daily/weekly for targets
    const tf4h = allInd['4h'] || allInd['1h'];
    const tfD = allInd['1d'];
    const smc4h = allSmc['4h'] || allSmc['1h'];
    if (!tf4h) return null;
    const isLong = direction === 'LONG' || direction === 'STRONG LONG';
    const price = tf4h.price;
    const atr = tf4h.atr.val || price * 0.02;

    // ── ENTRY ──
    let entry = price;
    if (isLong) {
      // Check for bullish FVG near price
      const fvg = smc4h?.fvgs?.find(f => f.type === 'bullish' && f.top >= price * 0.97 && f.bot <= price);
      if (fvg) entry = (fvg.top + fvg.bot) / 2;
      // Check bullish OB near price
      const ob = smc4h?.obs?.find(o => o.type === 'bullish' && o.high >= price * 0.97 && o.low <= price);
      if (ob) entry = Math.min(entry, (ob.high + ob.low) / 2);
      // 50% fib retracement
      const fib50 = tf4h.fibs?.find(f => f.r === 0.5);
      if (fib50 && fib50.p < price && fib50.p > price * 0.95) entry = Math.min(entry, fib50.p);
      // Kijun as support
      if (tf4h.ichimoku.kijun && tf4h.ichimoku.kijun < price && tf4h.ichimoku.kijun > price * 0.97)
        entry = Math.min(entry, tf4h.ichimoku.kijun);
    } else {
      const fvg = smc4h?.fvgs?.find(f => f.type === 'bearish' && f.bot <= price * 1.03 && f.top >= price);
      if (fvg) entry = (fvg.top + fvg.bot) / 2;
      const ob = smc4h?.obs?.find(o => o.type === 'bearish' && o.low <= price * 1.03 && o.high >= price);
      if (ob) entry = Math.max(entry, (ob.high + ob.low) / 2);
      const fib50 = tf4h.fibs?.find(f => f.r === 0.5);
      if (fib50 && fib50.p > price && fib50.p < price * 1.05) entry = Math.max(entry, fib50.p);
      if (tf4h.ichimoku.kijun && tf4h.ichimoku.kijun > price && tf4h.ichimoku.kijun < price * 1.03)
        entry = Math.max(entry, tf4h.ichimoku.kijun);
    }

    // ── ENTRY LADDER (scale-in zones + front-run offsets) ──
    const frOffset = atr * 0.15; // front-run offset: 15% of ATR
    const ladder = [];
    if (isLong) {
      // Aggressive: slightly above entry (front-run the obvious level)
      ladder.push({zone:'Aggressive', price: entry + frOffset, pct: 25, reason:'Front-runs the entry level by ' + fmtP(frOffset)});
      // Target: the calculated entry
      ladder.push({zone:'Target', price: entry, pct: 50, reason:'Primary entry at calculated level'});
      // Deep: below entry near OB/FVG/fib for a better fill
      let deepPrice = entry - atr * 0.5;
      let deepReason = 'Half ATR below entry';
      // Look for structural levels below
      const nearOB = smc4h?.obs?.find(o => o.type === 'bullish' && o.high < entry && o.high > entry - atr);
      if (nearOB) { deepPrice = nearOB.high; deepReason = 'Top of bullish order block'; }
      const nearFVG = smc4h?.fvgs?.find(f => f.type === 'bullish' && f.top < entry && f.top > entry - atr);
      if (nearFVG) { deepPrice = Math.min(deepPrice, nearFVG.top); deepReason = 'Top of bullish FVG'; }
      ladder.push({zone:'Deep', price: deepPrice, pct: 25, reason: deepReason});
    } else {
      ladder.push({zone:'Aggressive', price: entry - frOffset, pct: 25, reason:'Front-runs the entry level by ' + fmtP(frOffset)});
      ladder.push({zone:'Target', price: entry, pct: 50, reason:'Primary entry at calculated level'});
      let deepPrice = entry + atr * 0.5;
      let deepReason = 'Half ATR above entry';
      const nearOB = smc4h?.obs?.find(o => o.type === 'bearish' && o.low > entry && o.low < entry + atr);
      if (nearOB) { deepPrice = nearOB.low; deepReason = 'Bottom of bearish order block'; }
      const nearFVG = smc4h?.fvgs?.find(f => f.type === 'bearish' && f.bot > entry && f.bot < entry + atr);
      if (nearFVG) { deepPrice = Math.max(deepPrice, nearFVG.bot); deepReason = 'Bottom of bearish FVG'; }
      ladder.push({zone:'Deep', price: deepPrice, pct: 25, reason: deepReason});
    }
    // Detect if entry is near obvious levels (round numbers, pivots, fibs)
    const nearbyObvious = [];
    const roundNum = Math.round(entry / 1000) * 1000;
    if (Math.abs(entry - roundNum) < atr * 0.3) nearbyObvious.push({level: '$' + roundNum.toLocaleString(), type:'Round Number'});
    if (tf4h.pivots) {
      ['pp','s1','s2','r1','r2'].forEach(k => {
        const p = tf4h.pivots[k];
        if (p && Math.abs(entry - p) < atr * 0.2) nearbyObvious.push({level: fmtP(p), type:'Pivot ' + k.toUpperCase()});
      });
    }
    tf4h.fibs?.forEach(f => {
      if ([0.382, 0.5, 0.618].includes(f.r) && Math.abs(entry - f.p) < atr * 0.2)
        nearbyObvious.push({level: fmtP(f.p), type: (f.r*100).toFixed(1) + '% Fib'});
    });
    // Weighted avg entry
    const weightedEntry = ladder.reduce((s,l) => s + l.price * l.pct, 0) / 100;

    // ── TECHNICAL STOP LOSS (recommended by indicators) ──
    let techSl;
    if (isLong) {
      const candidates = [entry - 1.5 * atr];
      const swLow = smc4h?.swings?.lows?.slice(-3).map(l => l.price).filter(p => p < entry);
      if (swLow?.length) candidates.push(Math.max(...swLow) - atr * 0.1);
      const ob = smc4h?.obs?.find(o => o.type === 'bullish' && o.low < entry);
      if (ob) candidates.push(ob.low - atr * 0.1);
      if (tf4h.ichimoku.cloudBot && tf4h.ichimoku.cloudBot < entry) candidates.push(tf4h.ichimoku.cloudBot - atr * 0.1);
      if (tf4h.bb.squeeze && tf4h.bb.lower) candidates.push(tf4h.bb.lower);
      techSl = Math.max(...candidates);
      const minSl = entry * 0.995, maxSl = entry * 0.95;
      techSl = Math.min(techSl, minSl);
      techSl = Math.max(techSl, maxSl);
    } else {
      const candidates = [entry + 1.5 * atr];
      const swHigh = smc4h?.swings?.highs?.slice(-3).map(h => h.price).filter(p => p > entry);
      if (swHigh?.length) candidates.push(Math.min(...swHigh) + atr * 0.1);
      const ob = smc4h?.obs?.find(o => o.type === 'bearish' && o.high > entry);
      if (ob) candidates.push(ob.high + atr * 0.1);
      if (tf4h.ichimoku.cloudTop && tf4h.ichimoku.cloudTop > entry) candidates.push(tf4h.ichimoku.cloudTop + atr * 0.1);
      if (tf4h.bb.squeeze && tf4h.bb.upper) candidates.push(tf4h.bb.upper);
      techSl = Math.min(...candidates);
      const minSl = entry * 1.005, maxSl = entry * 1.05;
      techSl = Math.max(techSl, minSl);
      techSl = Math.min(techSl, maxSl);
    }

    // ── POSITION SIZING ──
    const atrPct = tf4h.atr.pct || 2;
    const lev = Math.max(1, userLev);
    const posSizeUSD = tradeCapital * lev;
    const posSizeBTC = posSizeUSD / entry;

    // ── RISK-BASED STOP LOSS ──
    // SL is derived from: maxLoss / position = SL distance %
    // If riskAmt is 0 or not set, fall back to technical SL
    let sl;
    if (riskAmt > 0 && posSizeUSD > 0) {
      const riskSlPct = riskAmt / posSizeUSD; // e.g. $100 / $10,000 = 1%
      sl = isLong ? entry * (1 - riskSlPct) : entry * (1 + riskSlPct);
    } else {
      sl = techSl;
    }

    const liqPrice = lev > 1 ? (isLong ? entry * (1 - 1/lev) : entry * (1 + 1/lev)) : 0;
    const margin = tradeCapital;

    // ── TAKE PROFITS ──
    const tps = [];
    if (isLong) {
      const res = smc4h?.sr?.filter(l => l.type === 'resistance' && l.price > entry).sort((a,b) => a.price - b.price);
      const fibE1 = tf4h.fibExts?.find(f => f.r === 1);
      tps.push({pct:33, price: Math.min(res?.[0]?.price || entry + 2*atr, fibE1?.p || entry + 2*atr, entry + 2*atr), label:'TP1'});
      const fibE2 = tf4h.fibExts?.find(f => f.r === 1.618);
      tps.push({pct:33, price: fibE2?.p || entry + 3.5*atr, label:'TP2'});
      const fibE3 = tf4h.fibExts?.find(f => f.r === 2);
      tps.push({pct:34, price: fibE3?.p || entry + 5*atr, label:'TP3'});
    } else {
      const sup = smc4h?.sr?.filter(l => l.type === 'support' && l.price < entry).sort((a,b) => b.price - a.price);
      tps.push({pct:33, price: Math.max(sup?.[0]?.price || entry - 2*atr, entry - 2*atr), label:'TP1'});
      tps.push({pct:33, price: entry - 3.5*atr, label:'TP2'});
      tps.push({pct:34, price: entry - 5*atr, label:'TP3'});
    }

    // ── RISK / REWARD ──
    const slDist = Math.abs(entry - sl);
    const slPct = slDist / entry;
    const slLoss = riskAmt > 0 ? riskAmt : posSizeUSD * slPct; // if risk set, loss = risk; else calc from techSl
    const techSlDist = Math.abs(entry - techSl);
    const techSlPct = techSlDist / entry * 100;
    const rr1 = slDist > 0 ? Math.abs(tps[0].price - entry) / slDist : 0;
    const rr2 = slDist > 0 ? Math.abs(tps[1].price - entry) / slDist : 0;
    const rr3 = slDist > 0 ? Math.abs(tps[2].price - entry) / slDist : 0;
    const avgRR = (rr1 * 0.33 + rr2 * 0.33 + rr3 * 0.34);

    // ── CONFIDENCE ──
    const abScore = Math.abs(composite.score);
    const confidence = Math.min(95, Math.max(15, abScore + (avgRR > 2 ? 10 : 0) + (smc4h?.divs?.length ? 5 : 0)));

    // ── ENTRY TIMING ──
    const timing = this._calcTiming(isLong, allInd, allSmc, composite, tf4h, smc4h, entry, price);

    // ── EXECUTIVE SUMMARY ──
    const summary = this._buildSummary(isLong, direction, allInd, allSmc, composite, tf4h, smc4h, entry, sl, tps, confidence, timing);

    return {
      direction: isLong ? 'LONG' : 'SHORT', entry, sl, techSl, tps, slDist, slPct: slPct * 100, techSlPct,
      rr: [rr1, rr2, rr3], avgRR, posSizeUSD, posSizeBTC, lev, liqPrice, margin, slLoss,
      tradeCapital, riskAmt, confidence, atrPct, price, timing, summary,
      ladder, weightedEntry, nearbyObvious, frOffset
    };
  },

  _calcTiming(isLong, allInd, allSmc, composite, tf4h, smc4h, entry, price) {
    const timing = { action: 'WAIT', confirmTF: null, reasons: [], countdown: null, conditions: [], entryType: 'market' };

    // ── Price proximity check ──
    const entryDist = Math.abs(price - entry) / price * 100; // percent away
    const priceNearEntry = entryDist < 0.3; // within 0.3%
    const priceFarFromEntry = entryDist > 0.5;

    if (priceFarFromEntry) {
      timing.entryType = 'limit';
      const above = price > entry;
      timing.reasons.push(`Current price ($${price.toLocaleString(undefined,{maximumFractionDigits:0})}) is ${entryDist.toFixed(1)}% ${above ? 'above' : 'below'} entry ($${entry.toLocaleString(undefined,{maximumFractionDigits:0})})`);
      timing.reasons.push(`Set a limit order at $${entry.toLocaleString(undefined,{maximumFractionDigits:0})} — do not market enter here`);
      timing.reasons.push('When price reaches the entry zone, confirm with a 15m candle close before executing');
    }

    // ── Check TF alignment ──
    const aligned = [], conflicting = [];
    for (const tf of TIMEFRAMES) {
      if (!allInd[tf] || !allSmc[tf]) continue;
      const s = Confluence.scoreTF(allInd[tf], allSmc[tf]).score;
      if ((isLong && s > 10) || (!isLong && s < -10)) aligned.push(tf);
      else if ((isLong && s < -10) || (!isLong && s > 10)) conflicting.push(tf);
    }

    const majorAligned = aligned.filter(tf => ['1w','1d','4h'].includes(tf)).length;
    const entryTFAligned = aligned.includes('1h') || aligned.includes('15m');

    // ── Determine action ──
    if (priceFarFromEntry) {
      // Price is not near entry — always wait regardless of alignment
      timing.action = 'SET LIMIT ORDER';
      timing.confirmTF = '15m';
      if (majorAligned >= 2 && entryTFAligned) {
        timing.reasons.push('Timeframes are well aligned — the setup is valid, but price needs to come to your entry');
      } else if (majorAligned >= 2) {
        timing.reasons.push('Higher timeframes aligned, lower timeframes not yet confirmed');
      }
    } else if (priceNearEntry && majorAligned >= 2 && entryTFAligned) {
      timing.action = 'ENTER NOW';
      timing.entryType = 'market';
      timing.reasons.push('Price is at entry level and all major + entry timeframes are aligned');
    } else if (priceNearEntry && majorAligned >= 2 && !entryTFAligned) {
      timing.action = 'WAIT FOR CONFIRMATION';
      const waitTF = !aligned.includes('1h') ? '1h' : '15m';
      timing.confirmTF = waitTF;
      timing.reasons.push(`Price is near entry, but ${TF_LABELS[waitTF]} has not confirmed direction yet`);
      timing.reasons.push(`Wait for ${TF_LABELS[waitTF]} candle close to align before entering`);
    } else if (priceNearEntry && majorAligned < 2) {
      timing.action = 'WAIT FOR CONFIRMATION';
      timing.confirmTF = '4h';
      timing.reasons.push('Price is near entry but not enough timeframe alignment');
      timing.reasons.push('Wait for 4H candle close to strengthen the signal');
    } else {
      // Price somewhat near but not quite
      timing.action = 'WAIT FOR CONFIRMATION';
      timing.confirmTF = '15m';
      timing.reasons.push(`Price is ${entryDist.toFixed(1)}% from entry — getting close`);
      timing.reasons.push('Watch for price to reach entry zone, then confirm with 15m close');
    }

    if (conflicting.length > 0) {
      timing.reasons.push(`Conflicting signals on: ${conflicting.map(tf => TF_LABELS[tf]).join(', ')}`);
    }

    // ── Candle countdown ──
    const now = Date.now();
    const intervals = {'15m':15*60*1000,'1h':60*60*1000,'4h':4*60*60*1000};
    const countdowns = [];
    for (const [tf, ms] of Object.entries(intervals)) {
      if (!allInd[tf]?.candles?.length) continue;
      const lastTime = allInd[tf].candles[allInd[tf].candles.length - 1].time;
      const nextClose = lastTime + ms;
      const remaining = Math.max(0, nextClose - now);
      if (remaining > 0) {
        const mins = Math.floor(remaining / 60000);
        const hrs = Math.floor(mins / 60);
        const m = mins % 60;
        countdowns.push({ tf, remaining, label: hrs > 0 ? `${hrs}h ${m}m` : `${m}m` });
      }
    }
    timing.countdowns = countdowns;

    // ── Pending conditions / watch-for ──
    if (tf4h.rsi != null) {
      if (isLong && tf4h.rsi < 40 && tf4h.rsi > 25) timing.conditions.push('RSI approaching oversold on 4H — potential bounce zone');
      if (!isLong && tf4h.rsi > 60 && tf4h.rsi < 75) timing.conditions.push('RSI approaching overbought on 4H — potential rejection zone');
    }
    if (tf4h.macd.hist != null) {
      const hist = tf4h.macd.hist;
      if (isLong && hist < 0 && hist > -50) timing.conditions.push('MACD histogram narrowing on 4H — momentum shift building');
      if (!isLong && hist > 0 && hist < 50) timing.conditions.push('MACD histogram fading on 4H — bearish momentum building');
    }
    if (tf4h.bb.squeeze) timing.conditions.push('Bollinger Band squeeze active — expect volatility expansion');
    if (smc4h?.divs?.length) {
      for (const d of smc4h.divs) {
        if ((isLong && d.type.includes('Bullish')) || (!isLong && d.type.includes('Bearish')))
          timing.conditions.push(`${d.type} ${d.ind} divergence supports the setup`);
      }
    }

    return timing;
  },

  _buildSummary(isLong, direction, allInd, allSmc, composite, tf4h, smc4h, entry, sl, tps, confidence, timing) {
    const dir = isLong ? 'long (buy)' : 'short (sell)';
    const strength = Math.abs(composite.score) >= 60 ? 'strong' : 'moderate';
    const price = tf4h.price;

    // Build reason parts
    const reasons = [];

    // Trend reason
    const emaCount = [9,21,50,100,200].filter(p => tf4h.ema[p] != null && (isLong ? price > tf4h.ema[p] : price < tf4h.ema[p])).length;
    if (emaCount >= 4) reasons.push(`price is ${isLong ? 'above' : 'below'} ${emaCount} of 5 moving averages`);
    else if (emaCount >= 3) reasons.push(`price is ${isLong ? 'above' : 'below'} most moving averages`);

    // Ichimoku
    if (tf4h.ichimoku.pos === 'Above Cloud' && isLong) reasons.push('trading above the Ichimoku cloud');
    else if (tf4h.ichimoku.pos === 'Below Cloud' && !isLong) reasons.push('trading below the Ichimoku cloud');

    // Structure
    if (smc4h?.structure === 'bullish' && isLong) reasons.push('bullish market structure intact');
    else if (smc4h?.structure === 'bearish' && !isLong) reasons.push('bearish market structure intact');

    // RSI
    if (tf4h.rsi != null) {
      if (tf4h.rsi > 70) reasons.push('RSI is overbought suggesting a pullback is likely');
      else if (tf4h.rsi < 30) reasons.push('RSI is oversold suggesting a bounce is likely');
      else if (isLong && tf4h.rsi > 50) reasons.push('RSI shows bullish momentum');
      else if (!isLong && tf4h.rsi < 50) reasons.push('RSI shows bearish momentum');
    }

    // Volume
    if (tf4h.volRatio > 1.5) reasons.push('volume is elevated confirming the move');
    if (tf4h.obv > tf4h.obvPrev && isLong) reasons.push('on-balance volume is rising');
    else if (tf4h.obv < tf4h.obvPrev && !isLong) reasons.push('on-balance volume is declining');

    // MACD
    if (tf4h.macd.xover === 'Bullish' && isLong) reasons.push('MACD has crossed bullish');
    else if (tf4h.macd.xover === 'Bearish' && !isLong) reasons.push('MACD has crossed bearish');

    // Divergences
    if (smc4h?.divs?.length) {
      const relevant = smc4h.divs.filter(d => (isLong && d.type.includes('Bullish')) || (!isLong && d.type.includes('Bearish')));
      if (relevant.length) reasons.push(`${relevant[0].type.toLowerCase()} divergence detected on ${relevant[0].ind}`);
    }

    // Timeframe alignment
    const tfAligned = TIMEFRAMES.filter(tf => {
      if (!allInd[tf] || !allSmc[tf]) return false;
      const s = Confluence.scoreTF(allInd[tf], allSmc[tf]).score;
      return isLong ? s > 10 : s < -10;
    });
    if (tfAligned.length >= 4) reasons.push(`${tfAligned.length} of 5 timeframes agree on direction`);

    const reasonText = reasons.length > 0 ? reasons.slice(0, 4).join(', ') : 'multiple technical factors aligning';

    let actionText, headline, bodyPrefix;
    const priceStr = price.toLocaleString(undefined,{maximumFractionDigits:0});
    const entryStr = entry.toLocaleString(undefined,{maximumFractionDigits:0});
    const slStr = sl.toLocaleString(undefined,{maximumFractionDigits:0});
    const tp1Str = tps[0].price.toLocaleString(undefined,{maximumFractionDigits:0});
    const capStrength = strength.charAt(0).toUpperCase() + strength.slice(1);
    const bias = isLong ? 'bullish' : 'bearish';

    if (timing.action === 'ENTER NOW') {
      headline = `${capStrength} ${bias} setup — price is at entry level.`;
      bodyPrefix = `The analysis is ${bias} and price is at the suggested entry.`;
      actionText = 'Conditions are aligned — enter now.';
    } else if (timing.action === 'SET LIMIT ORDER') {
      const dist = ((Math.abs(price - entry) / price) * 100).toFixed(1);
      const side = price > entry ? 'above' : 'below';
      headline = `${capStrength} ${bias} bias — DO NOT enter at current price.`;
      bodyPrefix = `The analysis is ${bias}, but price ($${priceStr}) is ${dist}% ${side} the suggested entry ($${entryStr}). This is NOT an entry signal at the current price.`;
      actionText = `Set a limit order at $${entryStr} and wait. When price reaches the entry zone, confirm with a 15m candle close before executing.`;
    } else if (timing.confirmTF) {
      headline = `${capStrength} ${bias} bias — waiting for confirmation.`;
      bodyPrefix = `The analysis leans ${bias}, but the setup is not confirmed yet.`;
      actionText = `Wait for a ${TF_LABELS[timing.confirmTF]} candle close to confirm direction before entering.`;
    } else {
      headline = `${capStrength} ${bias} bias — not ready to trade.`;
      bodyPrefix = `The analysis leans ${bias}, but timeframes are not aligned for a trade.`;
      actionText = 'Wait for better timeframe alignment before considering an entry.';
    }

    return {
      headline,
      body: `${bodyPrefix} Composite score: ${composite.score > 0 ? '+' : ''}${composite.score}/100. Key reasons: ${reasonText}. Suggested setup: entry $${entryStr}, stop $${slStr}, first target $${tp1Str}.`,
      action: actionText,
      confidence: `Confidence: ${confidence}%.`,
    };
  }
};

// ═══════════════════════════════════════════════════════════════
// SESSION AWARENESS
// ═══════════════════════════════════════════════════════════════
const SESSIONS = [
  {name:'Asia',    color:'#f59e0b', openUTC:0,  closeUTC:9 },
  {name:'London',  color:'#3b82f6', openUTC:7,  closeUTC:16},
  {name:'New York',color:'#22c55e', openUTC:13, closeUTC:22},
];
function getSessionInfo() {
  const now = new Date();
  const utcH = now.getUTCHours();
  const utcM = now.getUTCMinutes();
  const utcS = now.getUTCSeconds();
  const nowSecs = utcH * 3600 + utcM * 60 + utcS;
  return SESSIONS.map(s => {
    const openSecs = s.openUTC * 3600;
    const closeSecs = s.closeUTC * 3600;
    const isOpen = nowSecs >= openSecs && nowSecs < closeSecs;
    let countdownSecs;
    if (isOpen) {
      countdownSecs = closeSecs - nowSecs;
    } else {
      countdownSecs = nowSecs < openSecs ? openSecs - nowSecs : (24 * 3600 - nowSecs) + openSecs;
    }
    const hrs = Math.floor(countdownSecs / 3600);
    const mins = Math.floor((countdownSecs % 3600) / 60);
    const secs = countdownSecs % 60;
    const countdown = `${hrs}h ${String(mins).padStart(2,'0')}m ${String(secs).padStart(2,'0')}s`;
    return {...s, isOpen, countdown, label: isOpen ? 'Closes' : 'Opens'};
  });
}

// ═══════════════════════════════════════════════════════════════
// FORMAT HELPERS
// ═══════════════════════════════════════════════════════════════
const fmt = (v, d = 2) => v != null ? Number(v).toFixed(d) : '—';
const fmtP = (v) => v != null ? '$' + Number(v).toLocaleString(undefined, {minimumFractionDigits:2,maximumFractionDigits:2}) : '—';
const fmtK = (v) => { if(v==null)return '—'; const a=Math.abs(v); return a>=1e9?(v/1e9).toFixed(1)+'B':a>=1e6?(v/1e6).toFixed(1)+'M':a>=1e3?(v/1e3).toFixed(1)+'K':fmt(v,0); };
const rCls = v => v==null?'muted':v>70?'bear':v<30?'bull':'';
const sCls = v => v==null?'muted':v>80?'bear':v<20?'bull':'';

// ═══════════════════════════════════════════════════════════════
// TOOLTIP SYSTEM
// ═══════════════════════════════════════════════════════════════
const TIPS = {
  // Card headers / sections
  confluence: 'Scores signals across 5 timeframes (15m to Weekly), weighted by importance. Range: -100 (strong short) to +100 (strong long). Neutral zone is -20 to +20.',
  tradeSetup: 'Auto-generated entry, stop loss, and 3 take-profit levels based on multi-timeframe confluence analysis and current price structure.',
  tfAnalysis: 'Detailed indicator breakdown for the selected timeframe. Switch tabs to compare signals across different time horizons.',
  keyLevels: 'Important horizontal price levels where buying or selling pressure is expected. Derived from pivots, Fibonacci, swing points, and round numbers.',
  scoreFactors: 'Every individual signal contributing to this timeframe\'s score. Positive points = bullish, negative = bearish. ADX multiplier amplifies scores when trend is strong.',
  summary: 'Plain-language interpretation of the current market setup, combining all indicators into an actionable narrative.',
  entryTiming: 'Real-time assessment of whether to enter now, set a limit order, or wait. Based on price proximity to entry and timeframe alignment.',
  journal: 'Personal trade log. Record setups, track outcomes (Win/Loss), and measure performance over time. Auto-saves to browser; export to Excel for permanent records.',
  priceChart: 'Candlestick chart with EMA overlays (9/21/50), Bollinger Bands, volume, and SMC markers (BOS/CHOCH). Trade levels drawn when a setup is active.',
  priceHistory: 'Clean area chart for visual price trend. Daily and Weekly go back to January 2017 (~3,300+ candles). 4H covers 1 year, 1H covers 90 days, 15m covers 14 days. Data is fetched once and cached.',

  // Trend indicators
  ema: 'Exponential Moving Average — weights recent prices more heavily. Price above = bullish bias, below = bearish. Shorter periods (9, 21) react faster than longer ones (100, 200).',
  sma50200: 'Simple Moving Averages. "Golden Cross" (50 crosses above 200) = major bullish signal. "Death Cross" (50 below 200) = bearish.',
  ichimoku: 'Japanese multi-signal indicator. Tenkan/Kijun cross shows momentum; cloud position shows trend bias. Price above cloud = bullish, inside = indecisive, below = bearish.',
  vwap: 'Volume-Weighted Average Price — the "fair value" for the period. Institutions use this as a benchmark. Price above = buyers in control.',

  // Momentum indicators
  rsi: 'Relative Strength Index (0-100). Above 70 = overbought (may pull back). Below 30 = oversold (may bounce). Divergences between RSI and price signal reversals.',
  macd: 'Moving Average Convergence Divergence. Histogram shows momentum strength. Bullish crossover = MACD line crosses above signal. Watch for divergences.',
  stochRsi: 'Stochastic RSI — an oscillator of RSI, more sensitive to short-term moves. K/D crossovers above 80 (overbought) or below 20 (oversold) are highest-probability signals.',
  adx: 'Average Directional Index — measures trend strength (not direction). Above 40 = strong trend, 20-40 = moderate, below 20 = weak/ranging. +DI vs -DI shows direction.',

  // Volatility
  bollinger: 'Price envelope: 2 standard deviations around a 20-period SMA. Squeeze (narrow bands) often precedes a breakout. Price at upper band = extended, lower band = compressed.',
  atr: 'Average True Range — volatility in dollar terms over 14 periods. Higher ATR means wider stop losses are needed. Used to calculate position sizing and leverage.',
  volRegime: 'Classifies current volatility: "Low Vol Squeeze" = breakout likely, "Normal" = typical conditions, "Elevated"/"Extreme" = high volatility, wider ranges expected.',

  // Volume
  volume: 'Current bar\'s trading volume compared to the 20-bar average. Spikes (>1.5x average) confirm price moves — strong volume validates the signal.',
  obv: 'On-Balance Volume — running total of volume flow. Rising OBV + rising price = strong trend. Divergence between OBV and price warns of weakening momentum.',

  // Market Structure (SMC)
  smcStructure: 'Smart Money Concepts (SMC) overall market structure. Determined by the pattern of Break of Structure and Change of Character events.',
  bos: 'Break of Structure — price breaks a prior swing high (bullish) or swing low (bearish), confirming the current trend is continuing.',
  choch: 'Change of Character — the first break against the prevailing trend. Signals a potential trend reversal. More significant on higher timeframes.',
  fvg: 'Fair Value Gaps — imbalances where a candle\'s range doesn\'t overlap with two candles prior. Price often returns to fill these gaps. Acts as support/resistance.',
  orderBlocks: 'Institutional supply/demand zones — the last opposing candle before a strong impulsive move. Smart money accumulates/distributes here.',
  liquidity: 'Clusters of stop losses resting above swing highs (buy-side) or below swing lows (sell-side). Smart money hunts these levels to fill large orders. "Equal Highs" (EQH) = multiple swing highs at the same price, creating a pool of buy stops above. "Equal Lows" (EQL) = multiple swing lows at the same price, creating sell stops below. These are high-probability liquidity sweep targets.',
  divergences: 'Price makes a new high/low but the indicator doesn\'t confirm — signals weakening momentum. "Regular" divergences signal reversals; "Hidden" signal continuation.',

  // Trade setup fields
  entry: 'Suggested entry price based on current market structure and signal direction.',
  stopLoss: 'Your stop loss, calculated from your max loss and leverage. Formula: SL = Entry × (1 ± MaxLoss/Position). Higher leverage = tighter stop. The "Technical SL" row shows where indicators suggest the stop should go — if your risk-based SL is tighter, you may get stopped out before the real level.',
  techSl: 'The stop loss recommended by technical analysis (ATR, swing lows, order blocks, Ichimoku cloud). Compare this to your risk-based SL above. If your SL is much tighter, consider reducing leverage so your stop has room to breathe.',
  tps: 'Three take-profit targets for scaling out: 33% at TP1 (conservative), 33% at TP2 (moderate), 34% at TP3 (aggressive). This locks in profits progressively.',
  riskReward: 'Ratio of potential loss (to stop) vs potential gain (to TP). Higher R:R = better risk-adjusted trade. Aim for at least 2:1.',
  positionSizing: 'Trade Capital = the $ you\'re putting up for this trade. Max Loss at SL = the most you\'re willing to lose. Leverage multiplies your position: $1,000 at 3x = $3,000 position. Use the comparison table to see how each leverage level affects your position, SL loss, TP gains, and liquidation price.',
  actualRisk: 'At higher leverage, your SL loss is amplified. Check if "Loss if SL hits" exceeds your max loss tolerance. If it does, reduce leverage or widen your capital. Liquidation = total loss of trade capital. At 1x (spot) there is no liquidation.',
  leverage: 'Select your leverage multiplier. 1x = spot (no leverage). 3x/5x/10x = leveraged position. Higher leverage = bigger gains AND bigger losses. The comparison table shows P&L at each level so you can see the trade-offs. Watch the "SL Loss" column — if it exceeds your max loss tolerance, use lower leverage.',
  liqPrice: 'Liquidation price — where your position is force-closed by the exchange. Keep this far from current price. Higher leverage = closer liquidation.',
  atrVol: 'Current ATR as a percentage of price. Influences stop loss distance and leverage. High volatility (>3%) means use lower leverage.',
  confidence: 'How likely this setup plays out (15-95%). Formula: starts with the absolute composite score (e.g. score of +65 → base 65%), then +10% if average R:R exceeds 2:1 (good reward for risk), and +5% if divergences are detected on the 4H timeframe (momentum confirmation). Clamped between 15% (minimum for any signal) and 95% (never 100% certain). Above 70% = high confidence. 50-70% = moderate. Below 50% = speculative.',
  whatChanged: 'Log of recent setup changes. The setup recalculates every 60 seconds as new candle data arrives. Tracked events: new signal activated (score left neutral zone), direction flipped (LONG↔SHORT), signal strength changed (e.g. LONG→STRONG LONG), entry/SL/TP levels shifted (price moved), and confidence changes (indicators aligned or weakened).',

  // Entry ladder
  tvChart: 'Interactive TradingView chart with full drawing tools, indicators, and symbol search. Your changes (drawings, indicators, timeframe) auto-save to your browser and persist across reloads. Click "Reset" to restore defaults. Click "Open My Chart" to launch your personal saved layout in a new tab.',
  entryLadder: 'Instead of one "all-in" entry, split your position across 3 price zones. "Aggressive" (25%) enters slightly ahead of the level to beat front-runners. "Target" (50%) is the primary calculated entry. "Deep" (25%) is below/above for a better fill if price overshoots. Weighted average entry is your effective cost basis.',
  frontRun: 'When entry sits near an obvious level (round number, pivot, major Fibonacci), institutions often front-run it — filling orders just before the level is reached. The "Aggressive" zone offsets by 15% of ATR to beat this. If you see multiple obvious levels clustering near entry, consider putting more allocation in the Aggressive zone.',

  // Entry timing
  candleCountdown: 'Time remaining on each timeframe\'s candle. Signals are most reliable at candle close — entering mid-candle risks false signals if the candle reverses.',
  tfAlignment: 'Whether higher timeframes (Daily, Weekly) agree with the trade direction. More alignment = higher conviction signal.',
  watchFor: 'Pending conditions that would strengthen or invalidate the setup. Monitor these before entering.',

  // Key levels
  pivots: 'Classic pivot points from prior period\'s high, low, close. R1-R3 are resistance levels (sell pressure). S1-S3 are support levels (buy pressure). PP is the pivot.',
  fibonacci: 'Fibonacci retracement levels from the swing range. 38.2%, 50%, and 61.8% are the most-watched levels where pullbacks often reverse.',
  supportResistance: 'Horizontal price levels from swing highs (resistance), swing lows (support), and round numbers. Price tends to react at these levels.',

  // Confluence meter details
  tfWeights: 'Higher timeframes are weighted more: Weekly 5x, Daily 4x, 4H 3x, 1H 2x, 15m 1x. This prevents noise from short-term fluctuations.',
  weightedTotal: 'Final composite score combining all timeframe signals by weight. Determines signal strength: ±60-100 = strong, ±20-60 = moderate, ±0-20 = neutral.',
  adxMult: 'ADX multiplier amplifies a timeframe\'s score when trend is strong (ADX > 20). Stronger trends get up to 1.5x multiplier, rewarding conviction.',

  // Journal
  winRate: 'Percentage of closed trades that were winners. Track this over time to measure your edge.',
  avgPnl: 'Average profit or loss percentage across all closed trades. Positive = profitable system overall.',
  avgRR: 'Average risk:reward ratio for winning trades only. Shows how much you capture on winners.',
};

function Tip({k}) {
  const text = TIPS[k];
  const [show, setShow] = useState(false);
  const [pos, setPos] = useState(null);
  const iconRef = useRef(null);
  const bubbleRef = useRef(null);
  if (!text) return null;
  const onEnter = () => { setPos(null); setShow(true); };
  const onLeave = () => { setShow(false); setPos(null); };
  useEffect(() => {
    if (!show || !iconRef.current || !bubbleRef.current) return;
    const r = iconRef.current.getBoundingClientRect();
    const bb = bubbleRef.current.getBoundingClientRect();
    const bw = 280;
    const iconCenter = r.left + r.width / 2;
    let left = iconCenter - bw / 2;
    // clamp to viewport edges
    if (left < 8) left = 8;
    if (left + bw > window.innerWidth - 8) left = window.innerWidth - bw - 8;
    // arrow should point at the icon center relative to the bubble
    const arrow = Math.max(12, Math.min(bw - 12, iconCenter - left));
    // vertical: prefer above, fall back to below
    let top, dir;
    if (r.top - bb.height - 10 < 0) {
      top = r.bottom + 8; dir = 'below';
    } else {
      top = r.top - bb.height - 8; dir = 'above';
    }
    setPos({top, left, dir, arrow});
  }, [show]);
  return (
    <>
      <span className="info-tip" ref={iconRef} onMouseEnter={onEnter} onMouseLeave={onLeave}>?</span>
      {show && ReactDOM.createPortal(
        <div ref={bubbleRef}
          className={`info-bubble-fixed ${pos ? pos.dir : 'above'} ${pos ? '' : 'positioning'}`}
          style={pos ? {top:pos.top, left:pos.left, '--arrow':pos.arrow+'px'} : {top:-9999, left:-9999}}>
          {text}
        </div>,
        document.body
      )}
    </>
  );
}

// ═══════════════════════════════════════════════════════════════
// REACT COMPONENTS
// ═══════════════════════════════════════════════════════════════

// ── Header ──
function Header({livePrice, change24h, lastRefresh, onRefresh}) {
  const [sessionInfo, setSessionInfo] = useState(getSessionInfo);
  useEffect(() => {
    const id = setInterval(() => setSessionInfo(getSessionInfo()), 1000);
    return () => clearInterval(id);
  }, []);
  return (
    <div className="header">
      <h2 style={{fontSize:18,letterSpacing:'-0.5px'}}>BTC Signal Desk</h2>
      {livePrice != null && (
        <span className="pulse" style={{fontSize:16,fontWeight:700,color:'var(--bull)',fontFamily:'JetBrains Mono'}}>
          ${livePrice.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2})}
        </span>
      )}
      {change24h != null && (
        <span style={{fontSize:12,fontWeight:600}} className={change24h >= 0 ? 'bull' : 'bear'}>
          {change24h >= 0 ? '+' : ''}{change24h.toFixed(2)}%
        </span>
      )}
      <div style={{display:'flex',gap:4,alignItems:'center',marginLeft:4}}>
        {sessionInfo.map(s => (
          <div key={s.name} className="session-pill" style={s.isOpen ? {borderColor: s.color + '44'} : {}}>
            <span className="session-dot" style={{background: s.isOpen ? s.color : 'var(--border2)', boxShadow: s.isOpen ? `0 0 5px ${s.color}` : 'none'}}></span>
            <span className="s-name" style={{color: s.isOpen ? s.color : 'var(--muted)'}}>{s.name}</span>
            <span className="s-timer">{s.label} {s.countdown}</span>
          </div>
        ))}
      </div>
      <div style={{marginLeft:'auto',display:'flex',alignItems:'center',gap:8,fontSize:11,color:'var(--muted)'}}>
        <a href="scalp.html" style={{color:'var(--warn)',textDecoration:'none',fontWeight:600,fontSize:12}}>Scalp Lab</a>
        {lastRefresh && <span>Updated {lastRefresh.toLocaleTimeString()}</span>}
        <button className="btn" onClick={onRefresh}>Refresh</button>
      </div>
    </div>
  );
}

// ── Confluence Meter ──
function ConfluenceMeter({tfScores, composite}) {
  const barColor = v => v > 20 ? 'var(--bull)' : v < -20 ? 'var(--bear)' : 'var(--accent)';
  const sigColor = {'STRONG LONG':'var(--bull)','LONG':'var(--bull)','NEUTRAL':'var(--accent)','SHORT':'var(--bear)','STRONG SHORT':'var(--bear)'};
  return (
    <div className="card">
      <div className="card-head" style={{cursor:'default'}}>
        <span>Confluence Score <Tip k="confluence" /></span>
        <span className="badge" style={{background: composite.score > 20 ? 'var(--bull-bg)' : composite.score < -20 ? 'var(--bear-bg)' : 'var(--accent-bg)', color: sigColor[composite.signal], borderColor: sigColor[composite.signal], borderWidth:1, borderStyle:'solid'}}>
          {composite.signal} ({composite.score > 0 ? '+' : ''}{composite.score})
        </span>
      </div>
      <div className="card-body">
        {TIMEFRAMES.map(tf => {
          const s = tfScores[tf];
          if (!s) return null;
          const pct = ((s.score + 100) / 200) * 100;
          return (
            <div key={tf} style={{marginBottom:6}}>
              <div style={{display:'flex',justifyContent:'space-between',fontSize:10,marginBottom:2}}>
                <span style={{color:'var(--dim)'}}>{TF_LABELS[tf]} <span style={{color:'var(--muted)'}}>({TF_WEIGHTS[tf]}x){tf === '1w' && <Tip k="tfWeights" />}</span></span>
                <span style={{color:barColor(s.score),fontWeight:600}}>{s.score > 0 ? '+' : ''}{s.score}</span>
              </div>
              <div className="meter-bar">
                <div style={{position:'absolute',left:'50%',top:0,bottom:0,width:1,background:'var(--border2)'}}></div>
                <div className="meter-fill" style={{width:`${pct}%`,background:barColor(s.score),opacity:0.7}}></div>
              </div>
            </div>
          );
        })}
        <div style={{marginTop:8,paddingTop:8,borderTop:'1px solid var(--border)',display:'flex',justifyContent:'space-between',fontSize:11}}>
          <span style={{fontWeight:600,color:'var(--text)'}}>Weighted Total <Tip k="weightedTotal" /></span>
          <span style={{fontWeight:700,fontSize:14,color:sigColor[composite.signal]}}>{composite.score > 0 ? '+' : ''}{composite.score}</span>
        </div>
      </div>
    </div>
  );
}

// ── Trade Setup Card ──
function TradeSetupCard({setup, tradeCapital, riskAmt, userLev, onCapitalChange, onRiskChange, onLevChange, composite, setupChanges}) {
  if (!setup) return (
    <div className="card" style={{opacity:0.6}}>
      <div className="card-head" style={{cursor:'default'}}>Trade Setup</div>
      <div className="card-body">
        <div style={{textAlign:'center',padding:20,color:'var(--muted)'}}>
          No active setup — score in neutral zone ({composite?.score ?? 0})
        </div>
        {setupChanges?.length > 0 && (
          <div style={{marginTop:8,borderTop:'1px solid var(--border)',paddingTop:8}}>
            <div className="sub-h" style={{display:'flex',alignItems:'center',gap:4}}>
              Recent Changes <Tip k="whatChanged" />
            </div>
            {setupChanges.slice(0,5).map((c, i) => {
              const icon = c.type === 'new' ? '\u25B6' : c.type === 'flip' ? '\u21C4' : c.type === 'cleared' ? '\u25A0' : c.type === 'strength' ? '\u2191' : c.type === 'confidence' ? '\u25CF' : '\u2022';
              const color = c.type === 'new' ? 'var(--bull)' : c.type === 'flip' ? 'var(--warn)' : c.type === 'cleared' ? 'var(--bear)' : 'var(--accent)';
              return (
                <div key={i} style={{display:'flex',gap:8,padding:'4px 0',borderBottom:'1px solid var(--border)',fontSize:11}}>
                  <span style={{color,fontSize:10,marginTop:2}}>{icon}</span>
                  <div style={{flex:1}}>
                    <div style={{color:'var(--text)'}}>{c.text}</div>
                    <div style={{color:'var(--muted)',fontSize:10}}>{c.detail}</div>
                  </div>
                  <span style={{color:'var(--muted)',fontSize:9}}>{c.ts}</span>
                </div>
              );
            })}
          </div>
        )}
      </div>
    </div>
  );
  const isLong = setup.direction === 'LONG';
  const glowCls = isLong ? 'glow-bull' : 'glow-bear';
  const dirColor = isLong ? 'var(--bull)' : 'var(--bear)';

  const copyPlan = () => {
    const txt = [
      `BTC ${setup.direction} SETUP`,
      `Generated: ${new Date().toLocaleString()}`,
      ``,
      `Entry: $${setup.entry.toFixed(2)}`,
      `Stop Loss: $${setup.sl.toFixed(2)} (${setup.slPct.toFixed(2)}%)`,
      `TP1 (33%): $${setup.tps[0].price.toFixed(2)} (R:R ${setup.rr[0].toFixed(1)})`,
      `TP2 (33%): $${setup.tps[1].price.toFixed(2)} (R:R ${setup.rr[1].toFixed(1)})`,
      `TP3 (34%): $${setup.tps[2].price.toFixed(2)} (R:R ${setup.rr[2].toFixed(1)})`,
      ``,
      `Trade Capital: $${tradeCapital} | Max Loss at SL: $${riskAmt}`,
      `Position: $${setup.posSizeUSD.toFixed(2)} (${setup.posSizeBTC.toFixed(6)} BTC)`,
      `Leverage: ${setup.lev}x | SL Loss: $${(setup.slLoss||0).toFixed(2)}`,
      `Liquidation: ${setup.liqPrice > 0 ? '$' + setup.liqPrice.toFixed(2) : 'N/A (spot)'}`,
      `Confidence: ${setup.confidence}% | Composite: ${composite.score}`,
      ``,
      `⚠️ Algorithmic analysis, not a recommendation. DYOR.`
    ].join('\n');
    navigator.clipboard.writeText(txt).then(() => alert('Trade plan copied to clipboard!'));
  };

  // R:R bar
  const totalDist = Math.abs(setup.tps[2].price - setup.sl);
  const slWidth = totalDist > 0 ? (setup.slDist / totalDist) * 100 : 20;
  const tpWidth = 100 - slWidth;

  return (
    <div className={`card ${glowCls} fade-in`}>
      <div className="card-head" style={{cursor:'default'}}>
        <span>Active Trade Setup <Tip k="tradeSetup" /></span>
        <span className={`badge ${isLong ? 'badge-bull' : 'badge-bear'}`}>{setup.direction}</span>
      </div>
      <div className="card-body">
        {/* Prices + Dollar P&L */}
        {(() => {
          const dir = isLong ? 1 : -1;
          const posBTC = setup.posSizeBTC;
          const cap = setup.tradeCapital || 1000;
          const slPnl = dir * (setup.sl - setup.entry) * posBTC;
          const tpPnls = setup.tps.map((tp, i) => {
            const portion = posBTC * (tp.pct / 100);
            return dir * (tp.price - setup.entry) * portion;
          });
          const totalIfAllTP = tpPnls.reduce((s,v) => s+v, 0);
          return (
            <table style={{marginBottom:8}}>
              <thead><tr><th>Level</th><th>Price</th><th style={{textAlign:'right'}}>P&L</th><th style={{textAlign:'right'}}>% Capital</th><th></th></tr></thead>
              <tbody>
                <tr><td className="muted">Entry <Tip k="entry" /></td><td style={{color:'var(--text)',fontWeight:600}}>{fmtP(setup.entry)}</td><td></td><td></td><td className="muted" style={{fontSize:10}}>Current: {fmtP(setup.price)}</td></tr>
                <tr style={{background:'var(--bear-bg)'}}>
                  <td className="bear">Stop Loss <Tip k="stopLoss" /></td>
                  <td className="bear" style={{fontWeight:600}}>{fmtP(setup.sl)}</td>
                  <td className="bear" style={{textAlign:'right',fontWeight:700}}>-${Math.abs(slPnl).toFixed(2)}</td>
                  <td className="bear" style={{textAlign:'right',fontWeight:600,fontSize:11}}>{fmt(slPnl / cap * 100, 1)}%</td>
                  <td className="muted" style={{fontSize:10}}>-{fmt(setup.slPct)}%</td>
                </tr>
                {setup.techSl && Math.abs(setup.techSl - setup.sl) > 1 && (
                  <tr style={{background:'rgba(59,130,246,0.05)'}}>
                    <td className="muted" style={{fontSize:10,paddingLeft:16}}>Technical SL <Tip k="techSl" /></td>
                    <td className="muted" style={{fontSize:11}}>{fmtP(setup.techSl)}</td>
                    <td></td><td></td>
                    <td className="muted" style={{fontSize:10}}>-{fmt(setup.techSlPct)}%</td>
                  </tr>
                )}
                {setup.tps.map((tp, i) => (
                  <tr key={i} style={{background:'var(--bull-bg)'}}>
                    <td className="bull">{tp.label} ({tp.pct}%){i === 0 && <Tip k="tps" />}</td>
                    <td className="bull" style={{fontWeight:600}}>{fmtP(tp.price)}</td>
                    <td className="bull" style={{textAlign:'right',fontWeight:700}}>+${tpPnls[i].toFixed(2)}</td>
                    <td className="bull" style={{textAlign:'right',fontWeight:600,fontSize:11}}>+{fmt(tpPnls[i] / cap * 100, 1)}%</td>
                    <td className="muted" style={{fontSize:10}}>R:R {fmt(setup.rr[i],1)}</td>
                  </tr>
                ))}
                <tr style={{borderTop:'1px solid var(--border2)'}}>
                  <td className="muted" style={{fontWeight:600}}>All TPs Hit</td>
                  <td></td>
                  <td className="bull" style={{textAlign:'right',fontWeight:700,fontSize:12}}>+${totalIfAllTP.toFixed(2)}</td>
                  <td className="bull" style={{textAlign:'right',fontWeight:700,fontSize:11}}>+{fmt(totalIfAllTP / cap * 100, 1)}%</td>
                  <td></td>
                </tr>
              </tbody>
            </table>
          );
        })()}

        <div style={{fontSize:10,color:'var(--muted)',lineHeight:1.4,marginBottom:6,padding:'4px 6px',background:'var(--card2)',borderRadius:4}}>
          P&L is on your {setup.lev}x position ({fmtP(setup.posSizeUSD)}). % Capital is return on your {fmtP(tradeCapital)} trade capital.
        </div>

        {/* R:R Bar */}
        <div style={{marginBottom:10}}>
          <div style={{fontSize:10,color:'var(--muted)',marginBottom:3}}>Risk : Reward <Tip k="riskReward" /></div>
          <div className="rr-bar">
            <div className="rr-sl" style={{width:`${Math.max(slWidth, 10)}%`}}>SL</div>
            <div className="rr-tp" style={{width:`${Math.max(tpWidth, 10)}%`}}>Avg R:R {fmt(setup.avgRR,1)}</div>
          </div>
        </div>

        {/* Position Sizing */}
        {(() => {
          const LEV_OPTIONS = [1, 3, 5, 10];
          const slLoss = setup.slLoss || 0;
          return (<>
            <div className="sub-h">Position Sizing <Tip k="positionSizing" /></div>
            <div style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:6,marginBottom:8}}>
              <div>
                <div style={{fontSize:11,color:'var(--muted)',marginBottom:2}}>Trade Capital</div>
                <input className="input" type="number" value={tradeCapital} onChange={e => onCapitalChange(+e.target.value)} style={{width:'100%'}} />
                <div style={{fontSize:9,color:'var(--muted)',marginTop:2}}>$ you're putting up</div>
              </div>
              <div>
                <div style={{fontSize:11,color:'var(--muted)',marginBottom:2}}>Max Loss at SL</div>
                <input className="input" type="number" value={riskAmt} onChange={e => onRiskChange(+e.target.value)} min="0" step="10" style={{width:'100%'}} />
                <div style={{fontSize:9,color:'var(--muted)',marginTop:2}}>$ most willing to lose</div>
              </div>
            </div>

            {/* Leverage Selector */}
            <div className="sub-h" style={{marginTop:4}}>Leverage <Tip k="leverage" /></div>
            <div style={{display:'flex',gap:4,marginBottom:8}}>
              {LEV_OPTIONS.map(l => (
                <button key={l} className={`btn ${l === userLev ? 'btn-accent' : ''}`}
                  style={{flex:1,padding:'6px 0',fontSize:13,fontWeight:700}}
                  onClick={() => onLevChange(l)}>
                  {l}x
                </button>
              ))}
            </div>

            {/* Position summary */}
            <div style={{background:'var(--card2)',border:'1px solid var(--border)',borderRadius:6,padding:'10px 12px',marginBottom:8,fontSize:12}}>
              <div style={{display:'flex',justifyContent:'space-between',marginBottom:5}}>
                <span style={{color:'var(--muted)'}}>Position Size</span>
                <span style={{color:'var(--text)',fontWeight:700,fontSize:14}}>{fmtP(setup.posSizeUSD)}</span>
              </div>
              <div style={{color:'var(--muted)',fontSize:10,textAlign:'right',marginTop:2}}>
                {fmtP(tradeCapital)} x {setup.lev}x = {fmtP(setup.posSizeUSD)} ({fmt(setup.posSizeBTC,6)} BTC)
              </div>
              <div style={{borderTop:'1px solid var(--border)',paddingTop:6,marginTop:6}}>
                <div style={{display:'flex',justifyContent:'space-between',marginBottom:3}}>
                  <span style={{color:'var(--muted)'}}>Your Stop Loss</span>
                  <span style={{color:'var(--bear)',fontWeight:600}}>{fmtP(setup.sl)} ({fmt(setup.slPct,2)}%)</span>
                </div>
                <div style={{display:'flex',justifyContent:'space-between',marginBottom:3}}>
                  <span style={{color:'var(--muted)'}}>Max Loss at SL</span>
                  <span style={{color:'var(--bear)',fontWeight:700}}>-{fmtP(slLoss)}</span>
                </div>
                {riskAmt > 0 && <div style={{color:'var(--muted)',fontSize:10,textAlign:'right'}}>
                  {fmtP(riskAmt)} / {fmtP(setup.posSizeUSD)} = {fmt(setup.slPct,2)}% from entry
                </div>}
              </div>
              {setup.lev > 1 && setup.liqPrice > 0 && (
                <div style={{borderTop:'1px solid var(--border)',paddingTop:6,marginTop:6}}>
                  <div style={{display:'flex',justifyContent:'space-between'}}>
                    <span style={{color: setup.lev > 3 ? 'var(--warn)' : 'var(--muted)'}}>Liquidation Price</span>
                    <span style={{color: setup.lev > 3 ? 'var(--warn)' : 'var(--dim)', fontWeight:600}}>{fmtP(setup.liqPrice)}</span>
                  </div>
                </div>
              )}
            </div>

            {/* SL tighter than technical warning */}
            {setup.techSl && riskAmt > 0 && (() => {
              const riskSlTighter = isLong ? setup.sl > setup.techSl : setup.sl < setup.techSl;
              if (!riskSlTighter) return null;
              const diff = Math.abs(setup.sl - setup.techSl);
              const diffPct = (diff / setup.entry * 100).toFixed(2);
              return (
                <div style={{background:'var(--warn-bg)',border:'1px solid rgba(245,158,11,0.3)',borderRadius:6,padding:'8px 10px',marginBottom:8,fontSize:11,lineHeight:1.5}}>
                  <div style={{color:'var(--warn)',fontWeight:600,marginBottom:3}}>SL is tighter than technical level</div>
                  <div style={{color:'var(--dim)'}}>
                    Your risk-based SL ({fmtP(setup.sl)}) is {diffPct}% tighter than the technical SL ({fmtP(setup.techSl)}). You may get stopped out before the real support/resistance level. Consider reducing leverage or increasing your max loss to give the trade room.
                  </div>
                </div>
              );
            })()}

            {/* Leverage Comparison Table */}
            <div style={{marginBottom:8}}>
              <div style={{fontSize:10,color:'var(--muted)',marginBottom:4,textTransform:'uppercase',letterSpacing:'0.5px'}}>Leverage Comparison <span style={{color:'var(--dim)',textTransform:'none'}}>(click row to select)</span></div>
              <table style={{fontSize:11}}>
                <thead>
                  <tr>
                    <th>Lev</th>
                    <th style={{textAlign:'right'}}>Position</th>
                    <th style={{textAlign:'right'}}>SL Price</th>
                    <th style={{textAlign:'right'}}>SL Loss</th>
                    <th style={{textAlign:'right'}}>TP1 Gain</th>
                    <th style={{textAlign:'right'}}>% Capital</th>
                    <th style={{textAlign:'right'}}>Liq Price</th>
                  </tr>
                </thead>
                <tbody>
                  {LEV_OPTIONS.map(l => {
                    const pos = tradeCapital * l;
                    const btc = pos / setup.entry;
                    const slP = riskAmt > 0 && pos > 0
                      ? (isLong ? setup.entry * (1 - riskAmt/pos) : setup.entry * (1 + riskAmt/pos))
                      : setup.techSl;
                    const tp1Gain = Math.abs(setup.tps[0].price - setup.entry) * btc;
                    const tp1PctCap = tradeCapital > 0 ? (tp1Gain / tradeCapital * 100) : 0;
                    const liq = l > 1 ? (isLong ? setup.entry * (1 - 1/l) : setup.entry * (1 + 1/l)) : null;
                    const active = l === userLev;
                    const tighterThanTech = isLong ? slP > setup.techSl : slP < setup.techSl;
                    return (
                      <tr key={l} style={{background: active ? 'rgba(59,130,246,0.15)' : 'transparent', cursor:'pointer', borderLeft: active ? '3px solid var(--accent)' : '3px solid transparent'}} onClick={() => onLevChange(l)}>
                        <td style={{fontWeight: active ? 700 : 400, color: active ? 'var(--accent)' : 'var(--dim)', fontSize: active ? 12 : 11}}>{l}x{active ? ' \u25C0' : ''}</td>
                        <td style={{textAlign:'right',color:'var(--text)',fontWeight: active ? 600 : 400}}>{fmtP(pos)}</td>
                        <td style={{textAlign:'right',color: tighterThanTech ? 'var(--warn)' : 'var(--bear)'}}>{fmtP(slP)}</td>
                        <td style={{textAlign:'right',color:'var(--bear)'}}>-{fmtP(riskAmt > 0 ? riskAmt : pos * Math.abs(setup.techSl - setup.entry) / setup.entry)}</td>
                        <td style={{textAlign:'right',color:'var(--bull)',fontWeight: active ? 700 : 400, fontSize: active ? 12 : 11}}>+{fmtP(tp1Gain)}</td>
                        <td style={{textAlign:'right',color:'var(--bull)',fontWeight: active ? 700 : 400}}>+{tp1PctCap.toFixed(1)}%</td>
                        <td style={{textAlign:'right',color: l > 3 ? 'var(--warn)' : 'var(--dim)'}}>{liq ? fmtP(liq) : '—'}</td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
              <div style={{fontSize:10,color:'var(--muted)',marginTop:4}}>
                TP1 Gain = full position gain if TP1 is hit. % Capital = return on your ${tradeCapital.toLocaleString()} trade capital.
              </div>
              {setup.techSl && <div style={{fontSize:10,color:'var(--muted)',marginTop:2}}>Technical SL: {fmtP(setup.techSl)} (-{fmt(setup.techSlPct)}%) — based on ATR, swing lows, order blocks</div>}
            </div>
          </>);
        })()}

        {/* Confidence */}
        {(() => {
          const conf = setup.confidence;
          const confLabel = conf >= 70 ? 'HIGH' : conf >= 50 ? 'MODERATE' : 'SPECULATIVE';
          const confColor = conf >= 70 ? 'var(--bull)' : conf >= 50 ? 'var(--warn)' : 'var(--bear)';
          const confBg = conf >= 70 ? 'var(--bull-bg)' : conf >= 50 ? 'var(--warn-bg)' : 'var(--bear-bg)';
          const confDim = conf >= 70 ? 'var(--bull-dim)' : conf >= 50 ? 'rgba(245,158,11,0.3)' : 'var(--bear-dim)';
          const abScore = Math.abs(composite.score);
          const rrBonus = setup.avgRR > 2;
          const divBonus = conf > abScore + (rrBonus ? 10 : 0);
          return (
            <div style={{marginTop:12,padding:'12px 14px',background:confBg,border:`1px solid ${confDim}`,borderRadius:8}}>
              <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',marginBottom:8}}>
                <span style={{fontSize:13,fontWeight:600,color:'var(--text)'}}>Confidence <Tip k="confidence" /></span>
                <div style={{display:'flex',alignItems:'baseline',gap:6}}>
                  <span className="badge" style={{background:confBg,color:confColor,border:`1px solid ${confColor}`,fontSize:10}}>{confLabel}</span>
                  <span style={{fontSize:22,fontWeight:700,color:confColor,fontFamily:'JetBrains Mono'}}>{conf}%</span>
                </div>
              </div>
              <div className="meter-bar" style={{height:8,marginBottom:8}}>
                <div className="meter-fill" style={{width:`${conf}%`,background:confColor,opacity:0.85}}></div>
              </div>
              <div style={{display:'flex',flexDirection:'column',gap:3,fontSize:11}}>
                <div style={{display:'flex',justifyContent:'space-between'}}>
                  <span style={{color:'var(--dim)'}}>Composite score magnitude</span>
                  <span style={{color:'var(--text)',fontWeight:600}}>{abScore}%</span>
                </div>
                <div style={{display:'flex',justifyContent:'space-between'}}>
                  <span style={{color:'var(--dim)'}}>R:R bonus ({'>'} 2:1)</span>
                  <span style={{color: rrBonus ? 'var(--bull)' : 'var(--muted)', fontWeight:600}}>{rrBonus ? '+10%' : '—'}</span>
                </div>
                <div style={{display:'flex',justifyContent:'space-between'}}>
                  <span style={{color:'var(--dim)'}}>4H divergence bonus</span>
                  <span style={{color: divBonus ? 'var(--bull)' : 'var(--muted)', fontWeight:600}}>{divBonus ? '+5%' : '—'}</span>
                </div>
              </div>
            </div>
          );
        })()}

        {/* What Changed */}
        {setupChanges?.length > 0 && (
          <div style={{marginTop:12}}>
            <div className="sub-h" style={{display:'flex',alignItems:'center',gap:4}}>
              What Changed <Tip k="whatChanged" />
            </div>
            <div style={{maxHeight:160,overflowY:'auto',paddingRight:4}}>
              {setupChanges.slice(0,10).map((c, i) => {
                const icon = c.type === 'new' ? '\u25B6' : c.type === 'flip' ? '\u21C4' : c.type === 'cleared' ? '\u25A0' : c.type === 'strength' ? '\u2191' : c.type === 'confidence' ? '\u25CF' : '\u2022';
                const color = c.type === 'new' ? 'var(--bull)' : c.type === 'flip' ? 'var(--warn)' : c.type === 'cleared' ? 'var(--bear)' : 'var(--accent)';
                return (
                  <div key={i} style={{display:'flex',gap:8,padding:'5px 0',borderBottom:'1px solid var(--border)',alignItems:'flex-start',fontSize:12}}>
                    <span style={{color,fontSize:11,marginTop:2,flexShrink:0}}>{icon}</span>
                    <div style={{flex:1,minWidth:0}}>
                      <div style={{color:'var(--text)',fontWeight:500}}>{c.text}</div>
                      <div style={{color:'var(--muted)',fontSize:11,marginTop:1}}>{c.detail}</div>
                    </div>
                    <span style={{color:'var(--muted)',fontSize:10,flexShrink:0,whiteSpace:'nowrap'}}>{c.ts}</span>
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* Disclaimer + Copy */}
        <div style={{marginTop:10,display:'flex',gap:6}}>
          <button className={`btn ${isLong ? 'btn-bull' : 'btn-bear'}`} style={{flex:1}} onClick={copyPlan}>Copy Trade Plan</button>
        </div>
        <div style={{fontSize:9,color:'var(--muted)',marginTop:6,lineHeight:1.4}}>
          This is an algorithmic analysis, not a recommendation. Verify all levels on your own charts before trading.
        </div>
      </div>
    </div>
  );
}

// ── Timeframe Analysis Panel ──
function TFPanel({tf, ind, smc}) {
  if (!ind) return null;
  const pa = v => ind.price > v ? 'bull' : 'bear';
  return (
    <div className="fade-in" style={{fontSize:11}}>
      {/* TREND */}
      <div className="sub-h">Trend <Tip k="ema" /></div>
      <table><tbody>
        {[9,21,50,100,200].map(p => (
          <tr key={p}><td className="muted">EMA {p}</td><td>{fmtP(ind.ema[p])}</td><td className={ind.ema[p]!=null?pa(ind.ema[p]):'muted'}>{ind.ema[p]!=null?(ind.price>ind.ema[p]?'Above':'Below'):'—'}</td></tr>
        ))}
        <tr><td className="muted">SMA 50/200 <Tip k="sma50200" /></td><td>{fmtP(ind.sma[50])}/{fmtP(ind.sma[200])}</td><td className={ind.cross.includes('Bullish')||ind.cross==='Golden Cross'?'bull':'bear'}>{ind.cross}</td></tr>
        <tr><td className="muted">Ichimoku <Tip k="ichimoku" /></td><td className="muted">T:{fmtP(ind.ichimoku.tenkan)} K:{fmtP(ind.ichimoku.kijun)}</td><td className={ind.ichimoku.pos==='Above Cloud'?'bull':ind.ichimoku.pos==='Below Cloud'?'bear':'warn'}>{ind.ichimoku.pos} | {ind.ichimoku.tkX}</td></tr>
        <tr><td className="muted">VWAP <Tip k="vwap" /></td><td>{fmtP(ind.vwap)}</td><td className={ind.vwap!=null?pa(ind.vwap):'muted'}>{ind.vwap!=null?(ind.price>ind.vwap?'Above':'Below'):'—'}</td></tr>
      </tbody></table>

      {/* MOMENTUM */}
      <div className="sub-h" style={{marginTop:8}}>Momentum</div>
      <table><tbody>
        <tr><td className="muted">RSI (14) <Tip k="rsi" /></td><td className={rCls(ind.rsi)}>{fmt(ind.rsi,1)}</td><td className={rCls(ind.rsi)}>{ind.rsi!=null?(ind.rsi>70?'Overbought':ind.rsi<30?'Oversold':'Neutral'):'—'}</td></tr>
        <tr><td className="muted">MACD <Tip k="macd" /></td><td className={ind.macd.line>0?'bull':'bear'}>{fmt(ind.macd.line)}</td><td className={ind.macd.xover==='Bullish'?'bull':'bear'}>{ind.macd.xover} (H:{fmt(ind.macd.hist)})</td></tr>
        <tr><td className="muted">Stoch RSI <Tip k="stochRsi" /></td><td className={sCls(ind.stochRSI.k)}>K:{fmt(ind.stochRSI.k,1)} D:{fmt(ind.stochRSI.d,1)}</td><td className={sCls(ind.stochRSI.k)}>{ind.stochRSI.k!=null?(ind.stochRSI.k>80?'Overbought':ind.stochRSI.k<20?'Oversold':'Neutral'):'—'}</td></tr>
        <tr><td className="muted">ADX <Tip k="adx" /></td><td>{fmt(ind.adx.val,1)}</td><td className={ind.adx.val>40?'bull':ind.adx.val>20?'warn':'muted'}>{ind.adx.val!=null?(ind.adx.val>40?'Strong':ind.adx.val>20?'Moderate':'Weak'):'—'} +DI:{fmt(ind.adx.pDI,0)} -DI:{fmt(ind.adx.mDI,0)}</td></tr>
      </tbody></table>

      {/* VOLATILITY */}
      <div className="sub-h" style={{marginTop:8}}>Volatility</div>
      <table><tbody>
        <tr><td className="muted">Bollinger <Tip k="bollinger" /></td><td>U:{fmtP(ind.bb.upper)} L:{fmtP(ind.bb.lower)}</td><td className={ind.bb.squeeze?'warn':'muted'}>BW:{fmt(ind.bb.bw)}% {ind.bb.squeeze?'SQUEEZE':''}</td></tr>
        <tr><td className="muted">ATR (14) <Tip k="atr" /></td><td>{fmtP(ind.atr.val)}</td><td>{fmt(ind.atr.pct)}% of price</td></tr>
        <tr><td className="muted">Vol Regime <Tip k="volRegime" /></td><td colSpan="2"><span className={`badge ${ind.volRegime==='Low Vol Squeeze'?'badge-warn':ind.volRegime==='Extreme Expansion'?'badge-bear':'badge-neutral'}`}>{ind.volRegime}</span></td></tr>
      </tbody></table>

      {/* VOLUME */}
      <div className="sub-h" style={{marginTop:8}}>Volume</div>
      <table><tbody>
        <tr><td className="muted">Volume <Tip k="volume" /></td><td>{fmtK(ind.volume)}</td><td className={ind.volRatio>1.5?'warn':'muted'}>{fmt(ind.volRatio)}x avg {ind.volRatio>1.5?'SPIKE':''}</td></tr>
        <tr><td className="muted">OBV <Tip k="obv" /></td><td>{fmtK(ind.obv)}</td><td className={ind.obv>ind.obvPrev?'bull':'bear'}>{ind.obv>ind.obvPrev?'Rising':'Falling'}</td></tr>
      </tbody></table>

      {/* SMC */}
      {smc && <>
        <div className="sub-h" style={{marginTop:8}}>Market Structure (SMC) <Tip k="smcStructure" /></div>
        <table><tbody>
          <tr><td className="muted">Structure</td><td colSpan="2"><span className={`badge ${smc.structure==='bullish'?'badge-bull':smc.structure==='bearish'?'badge-bear':'badge-neutral'}`}>{smc.structure.toUpperCase()}</span></td></tr>
          {smc.lastBOS && <tr><td className="muted">Last BOS <Tip k="bos" /></td><td className={smc.lastBOS.type==='bullish'?'bull':'bear'}>{smc.lastBOS.type}</td><td>{fmtP(smc.lastBOS.price)}</td></tr>}
          {smc.lastCHOCH && <tr><td className="warn">Last CHOCH <Tip k="choch" /></td><td className="warn">{smc.lastCHOCH.from} → {smc.lastCHOCH.type}</td><td>{fmtP(smc.lastCHOCH.price)}</td></tr>}
          <tr><td className="muted">Swings</td><td colSpan="2">{smc.stats.swH} highs / {smc.stats.swL} lows</td></tr>
          <tr><td className="muted">BOS Events</td><td colSpan="2">{smc.stats.bosN} total</td></tr>
        </tbody></table>

        {/* FVGs */}
        {smc.fvgs.length > 0 && <>
          <div className="sub-h" style={{marginTop:8}}>Fair Value Gaps (Unfilled) <Tip k="fvg" /></div>
          <table><thead><tr><th>Type</th><th>Zone</th><th>Gap</th></tr></thead><tbody>
            {smc.fvgs.slice(0,5).map((f,i) => (
              <tr key={i}><td className={f.type==='bullish'?'bull':'bear'}>{f.type}</td><td>{fmtP(f.bot)} — {fmtP(f.top)}</td><td>{fmtP(f.top - f.bot)}</td></tr>
            ))}
          </tbody></table>
        </>}

        {/* Order Blocks */}
        {smc.obs.length > 0 && <>
          <div className="sub-h" style={{marginTop:8}}>Order Blocks <Tip k="orderBlocks" /></div>
          <table><thead><tr><th>Type</th><th>Zone</th></tr></thead><tbody>
            {smc.obs.slice(0,5).map((o,i) => (
              <tr key={i}><td className={o.type==='bullish'?'bull':'bear'}>{o.type}</td><td>{fmtP(o.low)} — {fmtP(o.high)}</td></tr>
            ))}
          </tbody></table>
        </>}

        {/* Liquidity */}
        {smc.liq.length > 0 && <>
          <div className="sub-h" style={{marginTop:8}}>Liquidity Levels <Tip k="liquidity" /></div>
          <table><thead><tr><th>Type</th><th>Price</th></tr></thead><tbody>
            {smc.liq.slice(0,5).map((l,i) => (
              <tr key={i}><td className="warn">{l.type.replace('_',' ')}</td><td>{fmtP(l.price)}</td></tr>
            ))}
          </tbody></table>
        </>}

        {/* Divergences */}
        {smc.divs.length > 0 && <>
          <div className="sub-h" style={{marginTop:8}}>Divergences Detected <Tip k="divergences" /></div>
          <table><thead><tr><th>Type</th><th>Indicator</th><th>Detail</th></tr></thead><tbody>
            {smc.divs.map((d,i) => (
              <tr key={i}><td className={d.type.includes('Bullish')?'bull':'bear'}>{d.type}</td><td>{d.ind}</td><td className="muted" style={{whiteSpace:'normal',fontSize:10}}>{d.desc}</td></tr>
            ))}
          </tbody></table>
        </>}
      </>}
    </div>
  );
}

// ── TradingView Chart ──
const TV_STORAGE_KEY = 'btc_signal_desk_tv_state';
function TradingViewChart() {
  const containerRef = React.useRef(null);
  const widgetRef = React.useRef(null);
  const MY_CHART_URL = 'https://www.tradingview.com/chart/bKlJWA5U/';

  const resetChart = () => {
    try { localStorage.removeItem(TV_STORAGE_KEY); } catch(e) {}
    if (containerRef.current) {
      containerRef.current.innerHTML = '';
      widgetRef.current = null;
    }
    initWidget();
  };

  const initWidget = () => {
    if (!window.TradingView || !containerRef.current) return;
    const saved = (() => { try { return JSON.parse(localStorage.getItem(TV_STORAGE_KEY)); } catch(e) { return null; } })();
    const cfg = {
      container_id: 'tv-chart-container',
      autosize: true,
      symbol: 'BINANCE:BTCUSDT',
      interval: '240',
      timezone: 'America/New_York',
      theme: 'dark',
      style: '1',
      locale: 'en',
      toolbar_bg: '#111827',
      enable_publishing: false,
      hide_side_toolbar: false,
      allow_symbol_change: true,
      studies: ['MAExp@tv-basicstudies', 'RSI@tv-basicstudies', 'MACD@tv-basicstudies'],
      backgroundColor: '#0a0e17',
      gridColor: '#1e293b',
      save_image: false,
      auto_save_delay: 3,
    };
    if (saved) cfg.saved_data = saved;
    const w = new window.TradingView.widget(cfg);
    widgetRef.current = w;
    w.onChartReady && w.onChartReady(() => {
      try {
        w.subscribe && w.subscribe('onAutoSaveNeeded', () => {
          w.save && w.save((state) => {
            try { localStorage.setItem(TV_STORAGE_KEY, JSON.stringify(state)); } catch(e) {}
          });
        });
      } catch(e) {}
    });
  };

  React.useEffect(() => {
    if (!containerRef.current) return;
    const existing = containerRef.current.querySelector('iframe');
    if (existing) return;
    if (window.TradingView) { initWidget(); return; }
    const script = document.createElement('script');
    script.src = 'https://s3.tradingview.com/tv.js';
    script.async = true;
    script.onload = initWidget;
    document.head.appendChild(script);
    return () => { try { document.head.removeChild(script); } catch(e) {} };
  }, []);

  return (
    <div className="card">
      <div className="card-head" style={{cursor:'default', display:'flex', justifyContent:'space-between', alignItems:'center'}}>
        <span>TradingView Chart <Tip k="tvChart" /></span>
        <div style={{display:'flex', alignItems:'center', gap:12}}>
          <button onClick={resetChart} title="Reset chart to defaults"
            style={{fontSize:12, color:'#94a3b8', background:'transparent', border:'1px solid #334155', borderRadius:6, padding:'3px 10px', cursor:'pointer'}}>
            Reset
          </button>
          <a href={MY_CHART_URL} target="_blank" rel="noopener noreferrer"
            style={{fontSize:13, color:'#3b82f6', textDecoration:'none', display:'flex', alignItems:'center', gap:6, fontWeight:600}}>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>
            Open My Chart
          </a>
        </div>
      </div>
      <div id="tv-chart-container" ref={containerRef} style={{height:500, background:'#0a0e17', borderRadius:8, overflow:'hidden'}} />
    </div>
  );
}

// ── Bottom panels ──
function KeyLevelsPanel({ind, smc}) {
  if (!ind) return null;
  return (
    <div className="card">
      <div className="card-head" style={{cursor:'default'}}>Key Levels <Tip k="keyLevels" /></div>
      <div className="card-body" style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:12}}>
        <div>
          <div className="sub-h">Pivot Points <Tip k="pivots" /></div>
          <table><tbody>
            <tr><td className="bear">R3</td><td>{fmtP(ind.pivots.r3)}</td></tr>
            <tr><td className="bear">R2</td><td>{fmtP(ind.pivots.r2)}</td></tr>
            <tr><td className="bear">R1</td><td>{fmtP(ind.pivots.r1)}</td></tr>
            <tr><td className="warn">PP</td><td style={{fontWeight:600}}>{fmtP(ind.pivots.pp)}</td></tr>
            <tr><td className="bull">S1</td><td>{fmtP(ind.pivots.s1)}</td></tr>
            <tr><td className="bull">S2</td><td>{fmtP(ind.pivots.s2)}</td></tr>
            <tr><td className="bull">S3</td><td>{fmtP(ind.pivots.s3)}</td></tr>
          </tbody></table>
        </div>
        <div>
          <div className="sub-h">Fibonacci Retracement <Tip k="fibonacci" /></div>
          <table><thead><tr><th>Level</th><th>Price</th><th>Dist</th></tr></thead><tbody>
            {ind.fibs.map(f => (
              <tr key={f.r}><td className="muted">{(f.r*100).toFixed(1)}%</td><td>{fmtP(f.p)}</td><td className={ind.price>=f.p?'bull':'bear'}>{((ind.price-f.p)/ind.price*100).toFixed(2)}%</td></tr>
            ))}
          </tbody></table>
          {smc?.sr?.length > 0 && <>
            <div className="sub-h" style={{marginTop:8}}>Support / Resistance <Tip k="supportResistance" /></div>
            <table><thead><tr><th>Type</th><th>Price</th><th>Source</th></tr></thead><tbody>
              {smc.sr.slice(0,8).map((l,i) => (
                <tr key={i}><td className={l.type==='support'?'bull':'bear'}>{l.type}</td><td>{fmtP(l.price)}</td><td className="muted">{l.src}</td></tr>
              ))}
            </tbody></table>
          </>}
        </div>
      </div>
    </div>
  );
}

// ── Confluence Factor Detail ──
function FactorDetail({tfScores, selectedTF}) {
  const s = tfScores[selectedTF];
  if (!s || !s.factors.length) return null;
  return (
    <div className="card">
      <div className="card-head" style={{cursor:'default'}}>
        <span>Score Factors — {TF_LABELS[selectedTF]} <Tip k="scoreFactors" /></span>
        <span className="muted" style={{fontSize:10}}>ADX mult: {s.adxMult}x <Tip k="adxMult" /></span>
      </div>
      <div className="card-body">
        <table><thead><tr><th>Factor</th><th style={{textAlign:'right'}}>Pts</th></tr></thead><tbody>
          {s.factors.map((f,i) => (
            <tr key={i}><td className="muted" style={{whiteSpace:'normal'}}>{f.label}</td><td style={{textAlign:'right',fontWeight:600}} className={f.pts>0?'bull':f.pts<0?'bear':'muted'}>{f.pts>0?'+':''}{f.pts}</td></tr>
          ))}
        </tbody></table>
      </div>
    </div>
  );
}

// ── Executive Summary ──
function ExecutiveSummary({setup, composite}) {
  if (!setup?.summary) return (
    <div className="card" style={{opacity:0.6}}>
      <div className="card-head" style={{cursor:'default'}}>Summary <Tip k="summary" /></div>
      <div className="card-body" style={{padding:16,color:'var(--muted)',fontSize:12,lineHeight:1.6}}>
        No active signal. The composite score is in the neutral zone ({composite?.score ?? 0}), meaning there is no clear directional bias across timeframes. Wait for stronger alignment before considering a trade.
      </div>
    </div>
  );
  const isLong = setup.direction === 'LONG';
  const s = setup.summary;
  return (
    <div className="card fade-in" style={{borderLeft:`3px solid ${isLong ? 'var(--bull)' : 'var(--bear)'}`}}>
      <div className="card-head" style={{cursor:'default'}}>
        <span>Summary <Tip k="summary" /></span>
        <span className={`badge ${isLong ? 'badge-bull' : 'badge-bear'}`}>{setup.direction}</span>
      </div>
      <div className="card-body" style={{fontSize:12,lineHeight:1.7,color:'var(--dim)'}}>
        <p style={{fontWeight:600,color:'var(--text)',marginBottom:6,fontSize:13}}>{s.headline}</p>
        <p style={{marginBottom:6}}>{s.body}</p>
        <p style={{color: setup.timing?.action === 'ENTER NOW' ? 'var(--bull)' : 'var(--warn)', fontWeight:600, marginBottom:4}}>{s.action}</p>
        <p style={{color:'var(--muted)',fontSize:11}}>{s.confidence}</p>
      </div>
    </div>
  );
}

// ── Entry Timing ──
function EntryTiming({setup}) {
  if (!setup?.timing) return null;
  const t = setup.timing;
  const actionColor = t.action === 'ENTER NOW' ? 'var(--bull)' : t.action === 'SET LIMIT ORDER' ? 'var(--accent)' : 'var(--warn)';
  return (
    <div className="card">
      <div className="card-head" style={{cursor:'default'}}>
        <span>Entry Timing <Tip k="entryTiming" /></span>
        <span className="badge" style={{background: t.action === 'ENTER NOW' ? 'var(--bull-bg)' : 'var(--warn-bg)', color: actionColor, border: `1px solid ${actionColor}`}}>
          {t.action}
        </span>
      </div>
      <div className="card-body" style={{fontSize:11}}>
        {/* Candle countdowns */}
        {t.countdowns?.length > 0 && (
          <div style={{marginBottom:8}}>
            <div className="sub-h">Candle Close Countdown <Tip k="candleCountdown" /></div>
            <div style={{display:'flex',gap:8,flexWrap:'wrap'}}>
              {t.countdowns.map(c => (
                <div key={c.tf} style={{background:'var(--card2)',border:'1px solid var(--border)',borderRadius:6,padding:'4px 10px',textAlign:'center'}}>
                  <div style={{fontSize:10,color:'var(--muted)'}}>{TF_LABELS[c.tf]}</div>
                  <div style={{fontSize:13,fontWeight:600,color:'var(--text)'}}>{c.label}</div>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Alignment reasons */}
        {t.reasons.length > 0 && (
          <div style={{marginBottom:8}}>
            <div className="sub-h">Timeframe Alignment <Tip k="tfAlignment" /></div>
            {t.reasons.map((r,i) => (
              <div key={i} style={{display:'flex',gap:6,marginBottom:3,alignItems:'flex-start'}}>
                <span style={{color: r.includes('Conflicting') ? 'var(--bear)' : r.includes('confirm') || r.includes('aligned') ? 'var(--bull)' : 'var(--dim)', marginTop:1, fontSize:8}}>&#9679;</span>
                <span style={{color:'var(--dim)',lineHeight:1.4}}>{r}</span>
              </div>
            ))}
          </div>
        )}

        {/* Pending conditions */}
        {t.conditions.length > 0 && (
          <div>
            <div className="sub-h">Watch For <Tip k="watchFor" /></div>
            {t.conditions.map((c,i) => (
              <div key={i} style={{display:'flex',gap:6,marginBottom:3,alignItems:'flex-start'}}>
                <span style={{color:'var(--accent)',marginTop:1,fontSize:8}}>&#9679;</span>
                <span style={{color:'var(--dim)',lineHeight:1.4}}>{c}</span>
              </div>
            ))}
          </div>
        )}

        {t.confirmTF && (
          <div style={{marginTop:8,padding:'6px 10px',background:'var(--warn-bg)',borderRadius:6,color:'var(--warn)',fontSize:11,lineHeight:1.4}}>
            Suggested: wait for the {TF_LABELS[t.confirmTF]} candle to close before entering. Mid-candle entries carry higher risk of false signals.
          </div>
        )}

        {/* Entry Ladder */}
        {setup.ladder && (
          <div style={{marginTop:10}}>
            <div className="sub-h" style={{display:'flex',alignItems:'center',gap:4}}>Scale-In Ladder <Tip k="entryLadder" /></div>
            <div style={{background:'var(--card2)',border:'1px solid var(--border)',borderRadius:6,padding:'8px 10px',marginBottom:8}}>
              <table style={{fontSize:12}}>
                <thead><tr><th>Zone</th><th>Price</th><th>Allocation</th><th>Rationale</th></tr></thead>
                <tbody>
                  {setup.ladder.map((l,i) => (
                    <tr key={i}>
                      <td style={{color: l.zone==='Aggressive' ? 'var(--warn)' : l.zone==='Target' ? 'var(--accent)' : 'var(--bull)', fontWeight:600}}>{l.zone}</td>
                      <td style={{color:'var(--text)',fontWeight:500}}>{fmtP(l.price)}</td>
                      <td style={{color:'var(--dim)'}}>{l.pct}%</td>
                      <td style={{color:'var(--muted)',fontSize:11,whiteSpace:'normal'}}>{l.reason}</td>
                    </tr>
                  ))}
                  <tr style={{borderTop:'1px solid var(--border2)'}}>
                    <td style={{color:'var(--text)',fontWeight:600}}>Avg Entry</td>
                    <td style={{color:'var(--text)',fontWeight:700}}>{fmtP(setup.weightedEntry)}</td>
                    <td colSpan="2" style={{color:'var(--muted)',fontSize:11}}>Weighted avg across all 3 zones</td>
                  </tr>
                </tbody>
              </table>
            </div>

            {/* Nearby Obvious Levels */}
            {setup.nearbyObvious?.length > 0 && (
              <div style={{background:'var(--warn-bg)',border:'1px solid rgba(245,158,11,0.3)',borderRadius:6,padding:'8px 10px',marginBottom:4,fontSize:11}}>
                <div style={{color:'var(--warn)',fontWeight:600,marginBottom:4}}>Front-Run Warning <Tip k="frontRun" /></div>
                <div style={{color:'var(--dim)',marginBottom:4}}>Entry is near obvious levels that may get front-run:</div>
                {setup.nearbyObvious.map((o,i) => (
                  <div key={i} style={{display:'flex',gap:6,marginBottom:2}}>
                    <span style={{color:'var(--warn)'}}>&#9679;</span>
                    <span style={{color:'var(--text)'}}>{o.level}</span>
                    <span style={{color:'var(--muted)'}}>({o.type})</span>
                  </div>
                ))}
                <div style={{color:'var(--dim)',marginTop:4,lineHeight:1.4}}>
                  The "Aggressive" entry ({fmtP(setup.ladder[0].price)}) offsets by {fmtP(setup.frOffset)} (15% of ATR) to get filled before the crowd.
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}

// ═══════════════════════════════════════════════════════════════
// SIGNAL PERFORMANCE LOG — auto-tracks setup outcomes
// ═══════════════════════════════════════════════════════════════
const SIG_LOG_KEY = 'btc-signal-log';
const SIG_IDB_NAME = 'SignalDeskDB';
const SIG_IDB_STORE = 'signalLog';
const SIG_MIN_CONF = 50; // minimum confidence to auto-log

const SignalLog = {
  _load() { try { return JSON.parse(localStorage.getItem(SIG_LOG_KEY)) || []; } catch { return []; } },
  _save(log) {
    try { localStorage.setItem(SIG_LOG_KEY, JSON.stringify(log)); } catch {}
    this._saveIDB(log);
  },
  _openIDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(SIG_IDB_NAME, 1);
      req.onupgradeneeded = () => { req.result.createObjectStore(SIG_IDB_STORE); };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  },
  async _saveIDB(log) { try { const db = await this._openIDB(); const tx = db.transaction(SIG_IDB_STORE,'readwrite'); tx.objectStore(SIG_IDB_STORE).put(log,'trades'); } catch {} },
  async _loadIDB() { try { const db = await this._openIDB(); return new Promise(r => { const req = db.transaction(SIG_IDB_STORE,'readonly').objectStore(SIG_IDB_STORE).get('trades'); req.onsuccess = () => r(req.result||[]); req.onerror = () => r([]); }); } catch { return []; } },
  async restore() { let log = this._load(); if (log.length > 0) return log; log = await this._loadIDB(); if (log.length > 0) this._save(log); return log; },
  getAll() { return this._load(); },
  clear() { this._save([]); },

  logSetup(setup, composite) {
    if (!setup || !setup.entry) return 0;
    // Reject low-confidence setups
    if ((setup.confidence || 0) < SIG_MIN_CONF) return 0;
    const log = this._load();
    const dir = setup.direction.toLowerCase();
    const now = Date.now();
    // Cooldown: no new trade of ANY direction within 30 min of last logged trade
    const recentAny = log.some(t => (now - t.openTime) < 30 * 60 * 1000);
    if (recentAny) return 0;
    // Dedup: don't re-log if any same-direction trade is open OR was opened in last 4 hours
    const isDup = log.some(t => t.dir === dir && (t.status === 'open' || (now - t.openTime) < 4 * 60 * 60 * 1000));
    if (isDup) return 0;
    // SL clamping: if risk-based SL is >3x wider than technical SL, use tech SL + 50% buffer
    let sl = setup.sl;
    const techSl = setup.techSl || setup.sl;
    const riskSlDist = Math.abs(sl - setup.entry);
    const techSlDist = Math.abs(techSl - setup.entry);
    if (techSlDist > 0 && riskSlDist > techSlDist * 3) {
      sl = dir === 'long' ? setup.entry - techSlDist * 1.5 : setup.entry + techSlDist * 1.5;
    }
    log.push({
      id: Date.now() + '_' + Math.random().toString(36).slice(2, 7),
      dir,
      conf: setup.confidence || 0,
      composite: composite?.score || 0,
      signal: composite?.signal || '',
      entry: setup.entry,
      sl,
      tp1: setup.tps?.[0]?.price || 0,
      tp2: setup.tps?.[1]?.price || 0,
      tp3: setup.tps?.[2]?.price || 0,
      techSl,
      lev: setup.lev || 1,
      openTime: Date.now(),
      status: 'open',
      closeTime: null, closePrice: null, pnlPct: null, tp1Hit: false,
    });
    this._save(log);
    return 1;
  },

  checkOutcomes(candles15m) {
    if (!candles15m || candles15m.length < 2) return;
    const log = this._load();
    let changed = false;
    for (const t of log) {
      if (t.status !== 'open' && t.status !== 'win-tp1' && t.status !== 'win-tp2') continue;
      const isLong = t.dir === 'long';
      const relevantCandles = candles15m.filter(c => c.time >= t.openTime);
      if (relevantCandles.length === 0) continue;
      for (const c of relevantCandles) {
        const slHit = isLong ? c.low <= t.sl : c.high >= t.sl;
        const tp1Hit = isLong ? c.high >= t.tp1 : c.low <= t.tp1;
        const tp2Hit = isLong ? c.high >= t.tp2 : c.low <= t.tp2;
        const tp3Hit = t.tp3 && (isLong ? c.high >= t.tp3 : c.low <= t.tp3);
        if (t.status === 'open') {
          if (slHit) { t.status='loss'; t.closeTime=c.time; t.closePrice=t.sl; t.pnlPct=isLong?((t.sl-t.entry)/t.entry)*100:((t.entry-t.sl)/t.entry)*100; changed=true; break; }
          if (tp1Hit) { t.tp1Hit=true; if (tp2Hit) { if (tp3Hit) { t.status='win-tp3'; t.closeTime=c.time; t.closePrice=t.tp3; t.pnlPct=isLong?((t.tp3-t.entry)/t.entry)*100:((t.entry-t.tp3)/t.entry)*100; } else { t.status='win-tp2'; t.closeTime=c.time; t.closePrice=t.tp2; t.pnlPct=isLong?((t.tp2-t.entry)/t.entry)*100:((t.entry-t.tp2)/t.entry)*100; } changed=true; break; } t.status='win-tp1'; t.closeTime=c.time; t.closePrice=t.tp1; t.pnlPct=isLong?((t.tp1-t.entry)/t.entry)*100:((t.entry-t.tp1)/t.entry)*100; changed=true; }
        }
        if (t.status === 'win-tp1') {
          const beSlHit = isLong ? c.low <= t.entry : c.high >= t.entry;
          if (tp2Hit) { if (tp3Hit) { t.status='win-tp3'; t.closeTime=c.time; t.closePrice=t.tp3; t.pnlPct=isLong?((t.tp3-t.entry)/t.entry)*100:((t.entry-t.tp3)/t.entry)*100; } else { t.status='win-tp2'; t.closeTime=c.time; t.closePrice=t.tp2; t.pnlPct=isLong?((t.tp2-t.entry)/t.entry)*100:((t.entry-t.tp2)/t.entry)*100; } changed=true; break; }
          if (beSlHit && !tp2Hit) break;
        }
        if (t.status === 'win-tp2' && t.tp3) {
          const beSlHit = isLong ? c.low <= t.tp1 : c.high >= t.tp1;
          if (tp3Hit) { t.status='win-tp3'; t.closeTime=c.time; t.closePrice=t.tp3; t.pnlPct=isLong?((t.tp3-t.entry)/t.entry)*100:((t.entry-t.tp3)/t.entry)*100; changed=true; break; }
          if (beSlHit) break;
        }
      }
      // Expiry: 24h for main app setups (longer TFs)
      if (t.status === 'open' && (Date.now() - t.openTime) > 24 * 60 * 60 * 1000) {
        const lastC = candles15m[candles15m.length - 1];
        t.status='expired'; t.closeTime=Date.now(); t.closePrice=lastC?lastC.close:t.entry;
        t.pnlPct=isLong?((t.closePrice-t.entry)/t.entry)*100:((t.entry-t.closePrice)/t.entry)*100; changed=true;
      }
    }
    if (changed) this._save(log);
  },

  getStats(log) {
    const closed = log.filter(t => t.status !== 'open');
    const wins = closed.filter(t => t.status.startsWith('win'));
    const losses = closed.filter(t => t.status === 'loss');
    const expired = closed.filter(t => t.status === 'expired');
    const decided = wins.length + losses.length + expired.length;
    const totalPnl = closed.reduce((s,t) => s + (t.pnlPct||0), 0);
    return { total:closed.length, open:log.filter(t=>t.status==='open').length, wins:wins.length, losses:losses.length, expired:expired.length, totalPnl, winRate: decided > 0 ? wins.length/decided*100 : 0, avgWin: wins.length>0 ? wins.reduce((s,t)=>s+t.pnlPct,0)/wins.length : 0, avgLoss: losses.length>0 ? losses.reduce((s,t)=>s+t.pnlPct,0)/losses.length : 0 };
  },

  exportJSON(log) { const blob = new Blob([JSON.stringify(log,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`signal-log-${new Date().toISOString().slice(0,10)}.json`; a.click(); URL.revokeObjectURL(a.href); },
  importJSON(jsonStr) { try { const imp=JSON.parse(jsonStr); if(!Array.isArray(imp)) return{added:0,error:'Invalid format'}; return this._merge(imp); } catch(e){return{added:0,error:e.message};} },
  _merge(imported) {
    const log = this._load();
    const keys = new Set(log.map(t => `${t.openTime}_${t.dir}`));
    let added = 0;
    for (const t of imported) { const k=`${t.openTime}_${t.dir}`; if(keys.has(k)) continue; log.push(t); added++; }
    if (added > 0) { log.sort((a,b)=>a.openTime-b.openTime); this._save(log); }
    return {added, total: log.length};
  },

  exportExcel(log, tradeCapital, lev) {
    const posUSD = (tradeCapital||0) * Math.max(1,lev||1);
    const rows = log.map(t => {
      let dollarPnl = '—';
      if (t.pnlPct != null && t.entry && posUSD > 0) {
        const posBTC = posUSD / t.entry;
        const priceDiff = t.closePrice ? Math.abs(t.closePrice - t.entry) : 0;
        dollarPnl = ((t.pnlPct >= 0 ? 1 : -1) * posBTC * priceDiff).toFixed(2);
      }
      return { 'Time':new Date(t.openTime).toLocaleString(), 'Direction':t.dir.toUpperCase(), 'Confidence':t.conf+'%', 'Composite':t.composite, 'Signal':t.signal, 'Entry':t.entry?.toFixed(2), 'SL':t.sl?.toFixed(2), 'TP1':t.tp1?.toFixed(2), 'TP2':t.tp2?.toFixed(2), 'TP3':t.tp3?.toFixed(2), 'Status':t.status.toUpperCase(), 'Close Price':t.closePrice?.toFixed(2)||'—', 'P&L %':t.pnlPct!=null?t.pnlPct.toFixed(3)+'%':'—', '$ P&L':dollarPnl, 'Close Time':t.closeTime?new Date(t.closeTime).toLocaleString():'—' };
    });
    const ws = XLSX.utils.json_to_sheet(rows);
    ws['!cols'] = [{wch:18},{wch:8},{wch:10},{wch:10},{wch:14},{wch:12},{wch:12},{wch:12},{wch:12},{wch:12},{wch:10},{wch:12},{wch:10},{wch:12},{wch:18}];
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Signal Log');
    XLSX.writeFile(wb, `signal-log-${new Date().toISOString().slice(0,10)}.xlsx`);
  }
};

// ── Signal Performance Log Panel ──
function SignalLogPanel({log, onClear, onImport, tradeCapital, userLev}) {
  const [showAll, setShowAll] = useState(false);
  const [showBreakdown, setShowBreakdown] = useState(false);
  const [importMsg, setImportMsg] = useState(null);
  const fileRef = useRef(null);
  const lev = Math.max(1, userLev);
  const posUSD = tradeCapital * lev;
  const calcDollarPnl = (t) => {
    if (t.pnlPct == null || !t.entry) return null;
    const posBTC = posUSD / t.entry;
    const priceDiff = t.closePrice ? Math.abs(t.closePrice - t.entry) : 0;
    return (t.pnlPct >= 0 ? 1 : -1) * posBTC * priceDiff;
  };
  const stats = useMemo(() => {
    const s = SignalLog.getStats(log);
    const closed = log.filter(t => t.status !== 'open');
    s.totalDollar = closed.reduce((sum, t) => sum + (calcDollarPnl(t)||0), 0);
    // Breakdown by signal type
    const bySignal = {};
    for (const t of log) {
      const key = t.signal || 'Unknown';
      if (!bySignal[key]) bySignal[key] = {wins:0,losses:0,expired:0,open:0,totalPnl:0,totalDollar:0,count:0};
      const b = bySignal[key]; b.count++;
      if (t.status.startsWith('win')) { b.wins++; b.totalPnl+=t.pnlPct||0; b.totalDollar+=calcDollarPnl(t)||0; }
      else if (t.status==='loss') { b.losses++; b.totalPnl+=t.pnlPct||0; b.totalDollar+=calcDollarPnl(t)||0; }
      else if (t.status==='expired') { b.expired++; b.totalPnl+=t.pnlPct||0; b.totalDollar+=calcDollarPnl(t)||0; }
      else b.open++;
    }
    s.bySignal = Object.entries(bySignal).map(([name,b]) => ({name,...b, winRate:(b.wins+b.losses+b.expired)>0?(b.wins/(b.wins+b.losses+b.expired)*100):null})).sort((a,b)=>(b.winRate||0)-(a.winRate||0));
    // Confidence brackets
    const byConf = {'80+':{w:0,l:0},'70-79':{w:0,l:0},'60-69':{w:0,l:0},'<60':{w:0,l:0}};
    for (const t of closed) {
      const bucket = t.conf>=80?'80+':t.conf>=70?'70-79':t.conf>=60?'60-69':'<60';
      if (t.status.startsWith('win')) byConf[bucket].w++; else if (t.status==='loss') byConf[bucket].l++;
    }
    s.byConf = byConf;
    return s;
  }, [log, posUSD]);
  const displayed = showAll ? log.slice().reverse() : log.slice().reverse().slice(0, 20);
  const fmtTime = ts => { if (!ts) return '—'; const d=new Date(ts); return d.toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})+' '+d.toLocaleDateString([],{month:'short',day:'numeric'}); };
  const statusBadge = s => {
    if (s==='win-tp1') return <span className="badge badge-bull" style={{fontSize:9}}>WIN TP1</span>;
    if (s==='win-tp2') return <span className="badge badge-bull" style={{fontSize:9}}>WIN TP2</span>;
    if (s==='win-tp3') return <span className="badge badge-bull" style={{fontSize:9}}>WIN TP3</span>;
    if (s==='loss') return <span className="badge badge-bear" style={{fontSize:9}}>LOSS</span>;
    if (s==='expired') return <span className="badge" style={{fontSize:9,background:'var(--warn-bg)',color:'var(--warn)'}}>EXPIRED</span>;
    return <span className="badge" style={{fontSize:9}}>OPEN</span>;
  };
  const confBar = c => {
    const color = c>=75?'var(--bull)':c>=65?'var(--accent)':'var(--warn)';
    return <div style={{display:'flex',alignItems:'center',gap:4}}><span style={{fontSize:11,fontWeight:600,color,minWidth:28}}>{c}%</span><div style={{flex:1,height:4,borderRadius:2,background:'var(--border)',minWidth:30}}><div style={{width:`${c}%`,height:'100%',borderRadius:2,background:color}}/></div></div>;
  };
  const handleImportFile = (e) => {
    const file = e.target.files?.[0]; if (!file) return;
    const reader = new FileReader();
    if (file.name.endsWith('.json')) {
      reader.onload = () => { const r=SignalLog.importJSON(reader.result); if(r.error) setImportMsg({type:'error',text:`Import failed: ${r.error}`}); else { setImportMsg({type:'ok',text:`Imported ${r.added} new signals (${r.total} total)`}); onImport(); } setTimeout(()=>setImportMsg(null),5000); };
      reader.readAsText(file);
    }
    e.target.value = '';
  };

  return (
    <div className="card bottom-panel">
      <div className="card-head"><span>Signal Performance Log ({log.length} signals)</span><span style={{fontSize:11,color:'var(--muted)'}}>Auto-tracking</span></div>
      <div className="card-body">
        <div style={{display:'flex',gap:10,flexWrap:'wrap',marginBottom:10}}>
          <div className="journal-stat"><div className="val" style={{color:'var(--accent)'}}>{stats.open}</div><div className="lbl">Open</div></div>
          <div className="journal-stat"><div className="val" style={{color:'var(--bull)'}}>{stats.wins}</div><div className="lbl">Wins</div></div>
          <div className="journal-stat"><div className="val" style={{color:'var(--bear)'}}>{stats.losses}</div><div className="lbl">Losses</div></div>
          <div className="journal-stat"><div className="val" style={{color:stats.winRate>=50?'var(--bull)':'var(--bear)'}}>{stats.winRate.toFixed(0)}%</div><div className="lbl">Win Rate</div></div>
          <div className="journal-stat"><div className="val" style={{color:stats.totalPnl>=0?'var(--bull)':'var(--bear)'}}>{stats.totalPnl>=0?'+':''}{stats.totalPnl.toFixed(2)}%</div><div className="lbl">Total P&L</div></div>
          <div className="journal-stat"><div className="val" style={{color:stats.totalDollar>=0?'var(--bull)':'var(--bear)',fontSize:18}}>{stats.totalDollar>=0?'+':''}${Math.abs(stats.totalDollar).toFixed(2)}</div><div className="lbl">Total $ P&L</div></div>
          <div className="journal-stat"><div className="val bull">{stats.avgWin>0?'+':''}{stats.avgWin.toFixed(3)}%</div><div className="lbl">Avg Win</div></div>
          <div className="journal-stat"><div className="val bear">{stats.avgLoss.toFixed(3)}%</div><div className="lbl">Avg Loss</div></div>
        </div>
        <div style={{fontSize:11,color:'var(--muted)',marginBottom:8}}>$ P&L based on ${tradeCapital.toLocaleString()} capital at {lev}x leverage (${posUSD.toLocaleString()} position)</div>

        <button className="btn" style={{fontSize:11,marginBottom:8,color:'var(--accent)'}} onClick={()=>setShowBreakdown(!showBreakdown)}>{showBreakdown?'Hide':'Show'} Signal & Confidence Breakdown</button>
        {showBreakdown && stats.bySignal && (
          <div style={{marginBottom:12}}>
            <div style={{fontSize:12,fontWeight:700,color:'var(--text)',marginBottom:6}}>Performance by Signal Type</div>
            <div style={{overflowX:'auto'}}><table style={{fontSize:11}}><thead><tr><th>Signal</th><th>Signals</th><th>W</th><th>L</th><th>Exp</th><th>Win%</th><th>P&L %</th><th>$ P&L</th></tr></thead><tbody>
              {stats.bySignal.map(b => (<tr key={b.name}><td style={{fontWeight:600}}>{b.name}</td><td>{b.count}</td><td className="bull">{b.wins}</td><td className="bear">{b.losses}</td><td style={{color:'var(--warn)'}}>{b.expired}</td><td style={{fontWeight:700,color:b.winRate==null?'var(--muted)':b.winRate>=50?'var(--bull)':'var(--bear)'}}>{b.winRate!=null?b.winRate.toFixed(0)+'%':'—'}</td><td className={b.totalPnl>=0?'bull':'bear'}>{b.totalPnl>=0?'+':''}{b.totalPnl.toFixed(3)}%</td><td className={b.totalDollar>=0?'bull':'bear'} style={{fontWeight:700}}>{b.totalDollar>=0?'+':'-'}${Math.abs(b.totalDollar).toFixed(2)}</td></tr>))}
            </tbody></table></div>
            <div style={{fontSize:12,fontWeight:700,color:'var(--text)',margin:'12px 0 6px'}}>Win Rate by Confidence Level</div>
            <div style={{display:'flex',gap:12,flexWrap:'wrap'}}>
              {Object.entries(stats.byConf).map(([bucket,d]) => { const total=d.w+d.l; const wr=total>0?(d.w/total*100).toFixed(0):'—'; return (
                <div key={bucket} style={{background:'var(--card-bg)',border:'1px solid var(--border)',borderRadius:8,padding:'8px 14px',minWidth:100,textAlign:'center'}}>
                  <div style={{fontSize:13,fontWeight:700,color:'var(--accent)'}}>{bucket}%</div>
                  <div style={{fontSize:18,fontWeight:700,color:wr==='—'?'var(--muted)':Number(wr)>=50?'var(--bull)':'var(--bear)'}}>{wr}{wr!=='—'?'%':''}</div>
                  <div style={{fontSize:10,color:'var(--muted)'}}>{d.w}W / {d.l}L ({total} trades)</div>
                </div>); })}
            </div>
          </div>
        )}

        {importMsg && <div style={{padding:'8px 12px',marginBottom:8,borderRadius:6,fontSize:12,fontWeight:600,background:importMsg.type==='ok'?'var(--bull-bg)':'var(--bear-bg)',color:importMsg.type==='ok'?'var(--bull)':'var(--bear)',border:`1px solid ${importMsg.type==='ok'?'var(--bull)':'var(--bear)'}`}}>{importMsg.text}</div>}
        <input type="file" ref={fileRef} accept=".json" style={{display:'none'}} onChange={handleImportFile} />
        <div className="journal-toolbar" style={{marginBottom:10}}>
          <button className="btn" style={{fontSize:11}} onClick={()=>SignalLog.exportExcel(log,tradeCapital,lev)}>Export Excel</button>
          <button className="btn" style={{fontSize:11}} onClick={()=>SignalLog.exportJSON(log)}>Export JSON</button>
          <button className="btn" style={{fontSize:11,color:'var(--accent)'}} onClick={()=>fileRef.current?.click()}>Import JSON</button>
          <button className="btn" style={{fontSize:11}} onClick={()=>setShowAll(!showAll)}>{showAll?'Show Recent':`Show All (${log.length})`}</button>
          {log.length>0 && <button className="btn" style={{fontSize:11,color:'var(--bear)'}} onClick={()=>{if(confirm('Clear all logged signals?'))onClear();}}>Clear</button>}
          <span style={{fontSize:10,color:'var(--muted)',marginLeft:'auto'}}>Auto-saved + IndexedDB backup</span>
        </div>

        {displayed.length > 0 ? (
          <div style={{overflowX:'auto'}}>
            <table><thead><tr><th>Time</th><th>Dir</th><th>Conf</th><th>Score</th><th>Entry</th><th>SL</th><th>TP1</th><th>Status</th><th>P&L %</th><th>$ P&L</th></tr></thead>
            <tbody>{displayed.map(t => {
              const dp = calcDollarPnl(t);
              return (<tr key={t.id} style={{background:t.status.startsWith('win')?'var(--bull-bg)':t.status==='loss'?'var(--bear-bg)':'transparent'}}>
                <td style={{fontSize:10,whiteSpace:'nowrap'}}>{fmtTime(t.openTime)}</td>
                <td><span className={`badge ${t.dir==='long'?'badge-bull':'badge-bear'}`} style={{fontSize:9}}>{t.dir.toUpperCase()}</span></td>
                <td>{confBar(t.conf)}</td>
                <td style={{fontWeight:600,color:t.composite>0?'var(--bull)':t.composite<0?'var(--bear)':'var(--muted)'}}>{t.composite>0?'+':''}{t.composite}</td>
                <td>{fmtP(t.entry)}</td>
                <td className="bear">{fmtP(t.sl)}</td>
                <td className="bull">{fmtP(t.tp1)}</td>
                <td>{statusBadge(t.status)}</td>
                <td className={t.pnlPct>0?'bull':t.pnlPct<0?'bear':'muted'} style={{fontWeight:600}}>{t.pnlPct!=null?`${t.pnlPct>0?'+':''}${t.pnlPct.toFixed(3)}%`:'—'}</td>
                <td className={dp>0?'bull':dp<0?'bear':'muted'} style={{fontWeight:700}}>{dp!=null?`${dp>0?'+':'-'}$${Math.abs(dp).toFixed(2)}`:'—'}</td>
              </tr>);
            })}</tbody></table>
          </div>
        ) : (
          <div style={{textAlign:'center',color:'var(--muted)',padding:20}}>
            <div>No signals logged yet. Auto-tracks setups as they appear.</div>
            <div style={{marginTop:10}}><button className="btn" style={{color:'var(--accent)',fontSize:12}} onClick={()=>fileRef.current?.click()}>Import a previous session (JSON)</button></div>
          </div>
        )}
      </div>
    </div>
  );
}

// ── Trade Journal ──
const JOURNAL_COLS = ['Date','Direction','Entry','Stop Loss','TP1','TP2','TP3','Actual Exit','Outcome','P&L %','R:R Achieved','Confidence','Composite','Notes'];

function journalFromSheet(ws) {
  const rows = XLSX.utils.sheet_to_json(ws, {defval:''});
  return rows.map((r, i) => ({
    id: i,
    date: r['Date'] || '',
    direction: r['Direction'] || '',
    entry: +r['Entry'] || 0,
    sl: +r['Stop Loss'] || 0,
    tp1: +r['TP1'] || 0,
    tp2: +r['TP2'] || 0,
    tp3: +r['TP3'] || 0,
    actualExit: r['Actual Exit'] !== '' ? +r['Actual Exit'] : null,
    outcome: r['Outcome'] || 'Pending',
    pnl: r['P&L %'] !== '' ? +r['P&L %'] : null,
    rrAchieved: r['R:R Achieved'] !== '' ? +r['R:R Achieved'] : null,
    confidence: +r['Confidence'] || 0,
    composite: +r['Composite'] || 0,
    notes: r['Notes'] || '',
  }));
}

function journalToSheet(trades) {
  const data = trades.map(t => ({
    'Date': t.date,
    'Direction': t.direction,
    'Entry': t.entry,
    'Stop Loss': t.sl,
    'TP1': t.tp1,
    'TP2': t.tp2,
    'TP3': t.tp3,
    'Actual Exit': t.actualExit ?? '',
    'Outcome': t.outcome,
    'P&L %': t.pnl ?? '',
    'R:R Achieved': t.rrAchieved ?? '',
    'Confidence': t.confidence,
    'Composite': t.composite,
    'Notes': t.notes,
  }));
  return XLSX.utils.json_to_sheet(data, {header: JOURNAL_COLS});
}

function TradeJournal({trades, onTradesChange, setup, composite}) {
  const fileRef = useRef(null);
  const [expanded, setExpanded] = useState(true);
  const [editingIdx, setEditingIdx] = useState(null);
  const [editNotes, setEditNotes] = useState('');
  const [editExit, setEditExit] = useState('');

  const logCurrent = () => {
    if (!setup) return;
    const newTrade = {
      id: Date.now(),
      date: new Date().toLocaleString(),
      direction: setup.direction,
      entry: +setup.entry.toFixed(2),
      sl: +setup.sl.toFixed(2),
      tp1: +setup.tps[0].price.toFixed(2),
      tp2: +setup.tps[1].price.toFixed(2),
      tp3: +setup.tps[2].price.toFixed(2),
      actualExit: null,
      outcome: 'Pending',
      pnl: null,
      rrAchieved: null,
      confidence: setup.confidence,
      composite: composite?.score ?? 0,
      notes: `${setup.timing?.action || ''} | ATR ${setup.atrPct?.toFixed(1)}% | Lev ${setup.lev}x`,
    };
    onTradesChange([newTrade, ...trades]);
  };

  const importFile = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (evt) => {
      try {
        const wb = XLSX.read(evt.target.result, {type:'array'});
        const ws = wb.Sheets[wb.SheetNames[0]];
        const imported = journalFromSheet(ws);
        onTradesChange([...imported, ...trades]);
      } catch (err) {
        alert('Failed to read Excel file: ' + err.message);
      }
    };
    reader.readAsArrayBuffer(file);
    e.target.value = '';
  };

  const exportFile = () => {
    if (!trades.length) return;
    const ws = journalToSheet(trades);
    // Column widths
    ws['!cols'] = JOURNAL_COLS.map(c => ({wch: c === 'Notes' ? 30 : c === 'Date' ? 20 : 12}));
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Trade Journal');
    XLSX.writeFile(wb, `BTC_Trade_Journal_${new Date().toISOString().slice(0,10)}.xlsx`);
  };

  const cycleOutcome = (idx) => {
    const next = {Pending: 'Win', Win: 'Loss', Loss: 'Pending'};
    const updated = [...trades];
    updated[idx] = {...updated[idx], outcome: next[updated[idx].outcome] || 'Pending'};

    // Auto-calc P&L if outcome set and exit price exists
    const t = updated[idx];
    if (t.outcome !== 'Pending' && t.actualExit) {
      const dir = t.direction === 'LONG' ? 1 : -1;
      t.pnl = +((dir * (t.actualExit - t.entry) / t.entry) * 100).toFixed(2);
      const slDist = Math.abs(t.entry - t.sl);
      if (slDist > 0) t.rrAchieved = +((Math.abs(t.actualExit - t.entry) / slDist) * (t.pnl >= 0 ? 1 : -1)).toFixed(2);
    }
    if (t.outcome === 'Pending') { t.pnl = null; t.rrAchieved = null; }
    onTradesChange(updated);
  };

  const startEdit = (idx) => {
    setEditingIdx(idx);
    setEditNotes(trades[idx].notes);
    setEditExit(trades[idx].actualExit ?? '');
  };

  const saveEdit = () => {
    if (editingIdx == null) return;
    const updated = [...trades];
    const t = {...updated[editingIdx]};
    t.notes = editNotes;
    t.actualExit = editExit !== '' ? +editExit : null;
    // Recalc P&L if exit set and not pending
    if (t.outcome !== 'Pending' && t.actualExit) {
      const dir = t.direction === 'LONG' ? 1 : -1;
      t.pnl = +((dir * (t.actualExit - t.entry) / t.entry) * 100).toFixed(2);
      const slDist = Math.abs(t.entry - t.sl);
      if (slDist > 0) t.rrAchieved = +((Math.abs(t.actualExit - t.entry) / slDist) * (t.pnl >= 0 ? 1 : -1)).toFixed(2);
    }
    updated[editingIdx] = t;
    onTradesChange(updated);
    setEditingIdx(null);
  };

  const deleteTrade = (idx) => {
    onTradesChange(trades.filter((_, i) => i !== idx));
  };

  // Stats
  const closed = trades.filter(t => t.outcome !== 'Pending');
  const wins = closed.filter(t => t.outcome === 'Win');
  const losses = closed.filter(t => t.outcome === 'Loss');
  const winRate = closed.length > 0 ? ((wins.length / closed.length) * 100).toFixed(0) : '—';
  const avgPnl = closed.length > 0 ? (closed.reduce((s,t) => s + (t.pnl || 0), 0) / closed.length).toFixed(2) : '—';
  const avgRR = wins.length > 0 ? (wins.reduce((s,t) => s + (t.rrAchieved || 0), 0) / wins.length).toFixed(1) : '—';

  return (
    <div className="card">
      <div className="card-head" onClick={() => setExpanded(!expanded)}>
        <span>Trade Journal ({trades.length} trades) <Tip k="journal" /></span>
        <span style={{fontSize:10,color:'var(--muted)'}}>{expanded ? '▼' : '▶'}</span>
      </div>
      {expanded && (
        <div className="card-body">
          {/* Toolbar */}
          <div className="journal-toolbar" style={{marginBottom:10}}>
            <button className="btn btn-accent" onClick={logCurrent} disabled={!setup} title={!setup ? 'No active setup to log' : 'Log current setup'}>
              + Log This Trade
            </button>
            <button className="btn" onClick={() => fileRef.current?.click()}>
              Import Excel
            </button>
            <input ref={fileRef} type="file" accept=".xlsx,.xls,.csv" className="journal-import" onChange={importFile} />
            <button className="btn" onClick={exportFile} disabled={!trades.length}>
              Export Excel
            </button>
            {closed.length > 0 && (
              <span style={{fontSize:10,color:'var(--muted)',marginLeft:'auto'}}>
                {wins.length}W / {losses.length}L
              </span>
            )}
          </div>

          {/* Stats */}
          {closed.length > 0 && (
            <div className="journal-stats">
              <div className="journal-stat">
                <div className="val">{trades.length}</div>
                <div className="lbl">Total</div>
              </div>
              <div className="journal-stat">
                <div className="val" style={{color: +winRate >= 50 ? 'var(--bull)' : +winRate > 0 ? 'var(--bear)' : 'var(--text)'}}>{winRate}%</div>
                <div className="lbl">Win Rate <Tip k="winRate" /></div>
              </div>
              <div className="journal-stat">
                <div className="val" style={{color: +avgPnl >= 0 ? 'var(--bull)' : 'var(--bear)'}}>{avgPnl}%</div>
                <div className="lbl">Avg P&L <Tip k="avgPnl" /></div>
              </div>
              <div className="journal-stat">
                <div className="val" style={{color:'var(--accent)'}}>{avgRR}</div>
                <div className="lbl">Avg R:R (W) <Tip k="avgRR" /></div>
              </div>
            </div>
          )}

          {/* Trade table */}
          {trades.length === 0 ? (
            <div style={{textAlign:'center',padding:20,color:'var(--muted)',fontSize:11}}>
              No trades logged yet. Click "Log This Trade" to record the current setup, or import an existing Excel file.
            </div>
          ) : (
            <div style={{overflowX:'auto'}}>
              <table style={{minWidth:700}}>
                <thead>
                  <tr>
                    <th>Date</th>
                    <th>Dir</th>
                    <th>Entry</th>
                    <th>SL</th>
                    <th>TP1</th>
                    <th>Exit</th>
                    <th>Outcome</th>
                    <th>P&L</th>
                    <th>R:R</th>
                    <th>Notes</th>
                    <th></th>
                  </tr>
                </thead>
                <tbody>
                  {trades.map((t, idx) => (
                    <tr key={t.id} style={{opacity: t.outcome === 'Pending' ? 1 : 0.85}}>
                      <td style={{fontSize:10,whiteSpace:'nowrap'}}>{t.date}</td>
                      <td><span className={`badge ${t.direction === 'LONG' ? 'badge-bull' : 'badge-bear'}`} style={{fontSize:9}}>{t.direction}</span></td>
                      <td>{fmtP(t.entry)}</td>
                      <td className="bear">{fmtP(t.sl)}</td>
                      <td className="bull">{fmtP(t.tp1)}</td>
                      <td>
                        {editingIdx === idx ? (
                          <input className="input" style={{width:80}} type="number" value={editExit} onChange={e => setEditExit(e.target.value)} placeholder="Exit $" />
                        ) : (
                          t.actualExit ? fmtP(t.actualExit) : <span className="muted">—</span>
                        )}
                      </td>
                      <td>
                        <button className={`outcome-btn outcome-${t.outcome.toLowerCase()}`} onClick={() => cycleOutcome(idx)} title="Click to cycle: Pending → Win → Loss">
                          {t.outcome}
                        </button>
                      </td>
                      <td style={{color: (t.pnl ?? 0) >= 0 ? 'var(--bull)' : 'var(--bear)', fontWeight:600}}>
                        {t.pnl != null ? `${t.pnl > 0 ? '+' : ''}${t.pnl}%` : '—'}
                      </td>
                      <td style={{color:'var(--accent)'}}>
                        {t.rrAchieved != null ? `${t.rrAchieved > 0 ? '+' : ''}${t.rrAchieved}` : '—'}
                      </td>
                      <td style={{fontSize:10,maxWidth:150,overflow:'hidden',textOverflow:'ellipsis'}}>
                        {editingIdx === idx ? (
                          <input className="input" style={{width:120}} value={editNotes} onChange={e => setEditNotes(e.target.value)} placeholder="Notes" />
                        ) : (
                          <span title={t.notes}>{t.notes || '—'}</span>
                        )}
                      </td>
                      <td style={{whiteSpace:'nowrap'}}>
                        {editingIdx === idx ? (
                          <button className="btn" style={{fontSize:9,padding:'2px 6px'}} onClick={saveEdit}>Save</button>
                        ) : (
                          <button className="btn" style={{fontSize:9,padding:'2px 6px'}} onClick={() => startEdit(idx)} title="Edit exit price & notes">Edit</button>
                        )}
                        <button className="btn" style={{fontSize:9,padding:'2px 6px',marginLeft:3,color:'var(--bear)'}} onClick={() => deleteTrade(idx)} title="Delete trade">×</button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      )}
    </div>
  );
}

// ── Chart Panel (TradingView Lightweight Charts) ──
function ChartPanel({candles, ind, smc, setup, tf}) {
  const containerRef = useRef(null);
  const chartRef = useRef(null);

  useEffect(() => {
    if (!containerRef.current || !candles || !candles.length) return;

    // Clean up previous chart
    if (chartRef.current) {
      chartRef.current.remove();
      chartRef.current = null;
    }

    const chart = LightweightCharts.createChart(containerRef.current, {
      layout: {background:{type:'solid',color:'#0d1320'},textColor:'#64748b',fontFamily:'JetBrains Mono',fontSize:10},
      grid: {vertLines:{color:'rgba(30,41,59,0.5)'},horzLines:{color:'rgba(30,41,59,0.5)'}},
      crosshair: {mode: LightweightCharts.CrosshairMode.Normal,vertLine:{color:'rgba(59,130,246,0.3)',labelBackgroundColor:'#1e293b'},horzLine:{color:'rgba(59,130,246,0.3)',labelBackgroundColor:'#1e293b'}},
      rightPriceScale: {borderColor:'#1e293b',scaleMargins:{top:0.1,bottom:0.25}},
      timeScale: {borderColor:'#1e293b',timeVisible:true,secondsVisible:false},
      handleScroll:true,handleScale:true,
    });
    chartRef.current = chart;

    // Candlestick series
    const candleSeries = chart.addCandlestickSeries({
      upColor:'#22c55e',downColor:'#ef4444',borderUpColor:'#22c55e',borderDownColor:'#ef4444',
      wickUpColor:'#22c55e80',wickDownColor:'#ef444480',
    });
    const candleData = candles.map(c => ({time: Math.floor(c.time / 1000), open:c.open, high:c.high, low:c.low, close:c.close}));
    candleSeries.setData(candleData);

    // Volume series
    const volSeries = chart.addHistogramSeries({
      priceFormat:{type:'volume'},
      priceScaleId:'vol',
    });
    chart.priceScale('vol').applyOptions({scaleMargins:{top:0.8,bottom:0}});
    volSeries.setData(candles.map(c => ({
      time: Math.floor(c.time / 1000),
      value: c.volume,
      color: c.close >= c.open ? 'rgba(34,197,94,0.2)' : 'rgba(239,68,68,0.2)',
    })));

    // EMA overlays
    const closes = candles.map(c => c.close);
    const addEMA = (period, color) => {
      const emaVals = Ind.ema(closes, period);
      const lineData = [];
      for (let i = 0; i < candles.length; i++) {
        if (emaVals[i] != null) lineData.push({time: Math.floor(candles[i].time / 1000), value: emaVals[i]});
      }
      if (lineData.length > 0) {
        const series = chart.addLineSeries({color, lineWidth:1, priceLineVisible:false, lastValueVisible:false, crosshairMarkerVisible:false});
        series.setData(lineData);
      }
    };
    addEMA(9, 'rgba(59,130,246,0.6)');   // blue
    addEMA(21, 'rgba(168,85,247,0.5)');   // purple
    addEMA(50, 'rgba(245,158,11,0.5)');   // amber

    // Bollinger Bands
    const bbData = Ind.bollinger(closes, 20, 2);
    const bbUpper = [], bbLower = [];
    for (let i = 0; i < candles.length; i++) {
      const t = Math.floor(candles[i].time / 1000);
      if (bbData.upper[i] != null) bbUpper.push({time:t, value:bbData.upper[i]});
      if (bbData.lower[i] != null) bbLower.push({time:t, value:bbData.lower[i]});
    }
    if (bbUpper.length) {
      const bU = chart.addLineSeries({color:'rgba(148,163,184,0.5)',lineWidth:1,lineStyle:2,priceLineVisible:false,lastValueVisible:false,crosshairMarkerVisible:false});
      bU.setData(bbUpper);
      const bL = chart.addLineSeries({color:'rgba(148,163,184,0.5)',lineWidth:1,lineStyle:2,priceLineVisible:false,lastValueVisible:false,crosshairMarkerVisible:false});
      bL.setData(bbLower);
    }

    // Trade setup price lines
    if (setup) {
      const addLine = (price, color, title, style) => {
        candleSeries.createPriceLine({price, color, lineWidth:1, lineStyle: style || 0, axisLabelVisible:true, title});
      };
      addLine(setup.entry, '#3b82f6', 'Entry', 2);
      addLine(setup.sl, '#ef4444', 'SL', 2);
      setup.tps.forEach(tp => addLine(tp.price, '#22c55e', tp.label, 2));
    }

    // BOS / CHOCH markers
    if (smc) {
      const markers = [];
      for (const b of (smc.bos || [])) {
        if (b.idx >= 0 && b.idx < candles.length) {
          markers.push({
            time: Math.floor(candles[b.idx].time / 1000),
            position: b.type === 'bullish' ? 'belowBar' : 'aboveBar',
            color: b.type === 'bullish' ? '#22c55e' : '#ef4444',
            shape: 'arrowUp',
            text: 'BOS',
          });
        }
      }
      for (const c of (smc.choch || [])) {
        if (c.idx >= 0 && c.idx < candles.length) {
          markers.push({
            time: Math.floor(candles[c.idx].time / 1000),
            position: c.type === 'bullish' ? 'belowBar' : 'aboveBar',
            color: '#f59e0b',
            shape: 'circle',
            text: 'CHOCH',
          });
        }
      }
      if (markers.length) {
        markers.sort((a, b) => a.time - b.time);
        candleSeries.setMarkers(markers);
      }
    }

    chart.timeScale().fitContent();

    // Resize observer
    const ro = new ResizeObserver(() => {
      if (containerRef.current) {
        chart.applyOptions({width: containerRef.current.clientWidth});
      }
    });
    ro.observe(containerRef.current);

    return () => { ro.disconnect(); chart.remove(); chartRef.current = null; };
  }, [candles, setup, smc, tf]);

  return (
    <div className="card">
      <div className="card-head" style={{cursor:'default'}}>
        <span>Price Chart — {TF_LABELS[tf]} <Tip k="priceChart" /></span>
        <div style={{display:'flex',gap:10,alignItems:'center',fontSize:11}}>
          <span style={{display:'flex',alignItems:'center',gap:3}}><span style={{width:14,height:3,borderRadius:2,background:'rgba(59,130,246,0.8)',display:'inline-block'}}></span><span style={{color:'var(--muted)'}}>EMA 9</span></span>
          <span style={{display:'flex',alignItems:'center',gap:3}}><span style={{width:14,height:3,borderRadius:2,background:'rgba(168,85,247,0.7)',display:'inline-block'}}></span><span style={{color:'var(--muted)'}}>EMA 21</span></span>
          <span style={{display:'flex',alignItems:'center',gap:3}}><span style={{width:14,height:3,borderRadius:2,background:'rgba(245,158,11,0.7)',display:'inline-block'}}></span><span style={{color:'var(--muted)'}}>EMA 50</span></span>
          <span style={{display:'flex',alignItems:'center',gap:3}}><span style={{width:14,height:2,borderRadius:1,background:'rgba(148,163,184,0.6)',display:'inline-block',borderTop:'1px dashed rgba(148,163,184,0.7)'}}></span><span style={{color:'var(--muted)'}}>BB</span></span>
        </div>
      </div>
      <div ref={containerRef} style={{height:400,background:'#0d1320'}}></div>
    </div>
  );
}

// ── Simple BTC Price History Chart ──
const HIST_START = 1483228800000; // Jan 1, 2017 UTC
const HIST_TFS = {
  '1d': {label:'Daily', start: HIST_START},
  '1w': {label:'Weekly', start: HIST_START},
  '4h': {label:'4H', start: Date.now() - 365*24*60*60*1000}, // 1 year for 4H
  '1h': {label:'1H', start: Date.now() - 90*24*60*60*1000},  // 90 days for 1H
  '15m':{label:'15m', start: Date.now() - 14*24*60*60*1000},  // 14 days for 15m
};

function PriceHistoryChart({allInd}) {
  const containerRef = useRef(null);
  const chartRef = useRef(null);
  const [chartTF, setChartTF] = useState('1d');
  const [histCandles, setHistCandles] = useState({});
  const [histLoading, setHistLoading] = useState(false);
  const [histCount, setHistCount] = useState(0);

  // Fetch historical data when TF changes
  useEffect(() => {
    let cancelled = false;
    const load = async () => {
      if (histCandles[chartTF]) { setHistCount(histCandles[chartTF].length); return; }
      setHistLoading(true);
      try {
        const startMs = HIST_TFS[chartTF]?.start || HIST_START;
        const data = await DataService.fetchHistorical(chartTF, startMs);
        if (!cancelled) {
          setHistCandles(prev => ({...prev, [chartTF]: data}));
          setHistCount(data.length);
        }
      } catch (e) {
        console.error('Historical fetch failed:', e);
        // fall back to allInd data
        if (!cancelled && allInd[chartTF]?.candles) {
          setHistCandles(prev => ({...prev, [chartTF]: allInd[chartTF].candles}));
          setHistCount(allInd[chartTF].candles.length);
        }
      }
      if (!cancelled) setHistLoading(false);
    };
    load();
    return () => { cancelled = true; };
  }, [chartTF]);

  // Render chart
  useEffect(() => {
    const candles = histCandles[chartTF];
    if (!containerRef.current || !candles || !candles.length) return;

    if (chartRef.current) { chartRef.current.remove(); chartRef.current = null; }

    const chart = LightweightCharts.createChart(containerRef.current, {
      layout: {background:{type:'solid',color:'#0d1320'},textColor:'#64748b',fontFamily:'JetBrains Mono',fontSize:10},
      grid: {vertLines:{color:'rgba(30,41,59,0.3)'},horzLines:{color:'rgba(30,41,59,0.3)'}},
      crosshair: {mode: LightweightCharts.CrosshairMode.Normal,vertLine:{color:'rgba(59,130,246,0.3)',labelBackgroundColor:'#1e293b'},horzLine:{color:'rgba(59,130,246,0.3)',labelBackgroundColor:'#1e293b'}},
      rightPriceScale: {borderColor:'#1e293b',scaleMargins:{top:0.05,bottom:0.05}},
      timeScale: {borderColor:'#1e293b',timeVisible:true,secondsVisible:false},
      handleScroll:true,handleScale:true,
    });
    chartRef.current = chart;

    // Area series for clean price view
    const areaSeries = chart.addAreaSeries({
      topColor: 'rgba(59,130,246,0.3)',
      bottomColor: 'rgba(59,130,246,0.02)',
      lineColor: '#3b82f6',
      lineWidth: 2,
      priceLineVisible: true,
      lastValueVisible: true,
      crosshairMarkerVisible: true,
    });
    areaSeries.setData(candles.map(c => ({time: Math.floor(c.time / 1000), value: c.close})));

    // Volume
    const volSeries = chart.addHistogramSeries({priceFormat:{type:'volume'},priceScaleId:'vol'});
    chart.priceScale('vol').applyOptions({scaleMargins:{top:0.85,bottom:0}});
    volSeries.setData(candles.map(c => ({
      time: Math.floor(c.time / 1000), value: c.volume,
      color: c.close >= c.open ? 'rgba(34,197,94,0.15)' : 'rgba(239,68,68,0.15)',
    })));

    chart.timeScale().fitContent();

    const ro = new ResizeObserver(() => {
      if (containerRef.current) chart.applyOptions({width: containerRef.current.clientWidth});
    });
    ro.observe(containerRef.current);
    return () => { ro.disconnect(); chart.remove(); chartRef.current = null; };
  }, [histCandles, chartTF]);

  return (
    <div className="card">
      <div className="card-head" style={{cursor:'default'}}>
        <span>BTC Price History <Tip k="priceHistory" />
          {histLoading && <span className="pulse" style={{fontSize:10,color:'var(--accent)',marginLeft:6}}>Loading...</span>}
          {!histLoading && histCount > 0 && <span style={{fontSize:10,color:'var(--muted)',marginLeft:6}}>({histCount.toLocaleString()} candles)</span>}
        </span>
        <div style={{display:'flex',gap:4}}>
          {TIMEFRAMES.map(tf => (
            <button key={tf} className="btn" onClick={() => setChartTF(tf)}
              style={{padding:'2px 8px',fontSize:9,background: tf===chartTF ? 'var(--accent-dim)' : undefined, color: tf===chartTF ? '#fff' : undefined, borderColor: tf===chartTF ? 'var(--accent)' : undefined}}>
              {TF_LABELS[tf]}
            </button>
          ))}
        </div>
      </div>
      <div ref={containerRef} style={{height:350,background:'#0d1320'}}></div>
    </div>
  );
}

// ═══════════════════════════════════════════════════════════════
// APP
// ═══════════════════════════════════════════════════════════════
function BackToTop() {
  const [vis, setVis] = useState(false);
  useEffect(() => {
    const onScroll = () => setVis(window.scrollY > 400);
    window.addEventListener('scroll', onScroll, {passive:true});
    return () => window.removeEventListener('scroll', onScroll);
  }, []);
  return <button className={'btt' + (vis?' vis':'')} onClick={() => window.scrollTo({top:0,behavior:'smooth'})} aria-label="Back to top">{'\u2191'}</button>;
}

function App() {
  const [allInd, setAllInd] = useState({});
  const [allSmc, setAllSmc] = useState({});
  const [tfScores, setTfScores] = useState({});
  const [composite, setComposite] = useState({score:0,signal:'NEUTRAL',breakdown:{}});
  const [setup, setSetup] = useState(null);
  const [livePrice, setLivePrice] = useState(null);
  const [ticker, setTicker] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [lastRefresh, setLastRefresh] = useState(null);
  const [status, setStatus] = useState('Initializing...');
  const [selectedTF, setSelectedTF] = useState('4h');
  const [tradeCapital, setTradeCapital] = useState(1000);
  const [riskAmt, setRiskAmt] = useState(100);
  const [userLev, setUserLev] = useState(1);
  const [journalTrades, setJournalTrades] = useState(() => {
    try { const s = localStorage.getItem('btc_journal'); return s ? JSON.parse(s) : []; } catch { return []; }
  });
  const updateJournal = useCallback((trades) => {
    setJournalTrades(trades);
    try { localStorage.setItem('btc_journal', JSON.stringify(trades)); } catch {}
  }, []);

  // Signal performance log (auto-tracking)
  const [signalLogData, setSignalLogData] = useState(() => SignalLog.getAll());
  const lastLoggedSignal = useRef(null);
  useEffect(() => { SignalLog.restore().then(log => { if (log.length > 0 && signalLogData.length === 0) setSignalLogData(log); }); }, []);

  const wsRef = useRef(null);
  const prevSetupRef = useRef(null);
  const prevCompositeRef = useRef(null);
  const [setupChanges, setSetupChanges] = useState([]);
  const detectChanges = (oldSetup, newSetup, oldComp, newComp) => {
    const changes = [];
    const ts = new Date().toLocaleTimeString();
    if (!oldSetup && newSetup) {
      changes.push({type:'new', ts, text:`New ${newSetup.direction} signal activated`, detail:`Composite crossed into ${newComp.signal} zone (score: ${newComp.score > 0 ? '+' : ''}${newComp.score})`});
    } else if (oldSetup && !newSetup) {
      changes.push({type:'cleared', ts, text:'Setup cleared — score returned to neutral', detail:`Composite score: ${newComp.score > 0 ? '+' : ''}${newComp.score} (neutral zone is -20 to +20)`});
    } else if (oldSetup && newSetup) {
      if (oldSetup.direction !== newSetup.direction) {
        changes.push({type:'flip', ts, text:`Direction flipped: ${oldSetup.direction} → ${newSetup.direction}`, detail:`Composite shifted from ${oldComp.score > 0 ? '+' : ''}${oldComp.score} to ${newComp.score > 0 ? '+' : ''}${newComp.score}`});
      }
      if (oldComp && newComp && oldComp.signal !== newComp.signal && oldSetup.direction === newSetup.direction) {
        changes.push({type:'strength', ts, text:`Signal strength: ${oldComp.signal} → ${newComp.signal}`, detail:`Score moved from ${oldComp.score > 0 ? '+' : ''}${oldComp.score} to ${newComp.score > 0 ? '+' : ''}${newComp.score}`});
      }
      const entryShift = Math.abs(newSetup.entry - oldSetup.entry) / oldSetup.entry * 100;
      if (entryShift > 0.1) {
        changes.push({type:'levels', ts, text:`Entry shifted ${entryShift > 0.3 ? 'significantly' : 'slightly'}: $${oldSetup.entry.toFixed(0)} → $${newSetup.entry.toFixed(0)}`, detail:`Price moved; SL and TPs recalculated. SL: $${newSetup.sl.toFixed(0)}, TP1: $${newSetup.tps[0].price.toFixed(0)}`});
      }
      if (oldSetup.confidence !== newSetup.confidence) {
        const dir = newSetup.confidence > oldSetup.confidence ? 'up' : 'down';
        changes.push({type:'confidence', ts, text:`Confidence ${dir}: ${oldSetup.confidence}% → ${newSetup.confidence}%`, detail: dir === 'up' ? 'Indicators aligned more strongly' : 'Some indicators weakened or diverged'});
      }
    }
    return changes;
  };

  const refresh = useCallback(async () => {
    try {
      setError(null);
      setStatus('Connecting...');
      const result = await DataService.fetchAll(setStatus);
      setStatus('Computing indicators...');
      const ind = {}, smc = {}, scores = {};
      for (const tf of TIMEFRAMES) {
        if (!result.candles[tf]) continue;
        ind[tf] = Ind.computeAll(result.candles[tf]);
        smc[tf] = SMC.computeAll(result.candles[tf], ind[tf].rsiArr, ind[tf].obvArr);
        scores[tf] = Confluence.scoreTF(ind[tf], smc[tf]);
      }
      const comp = Confluence.composite(scores);
      let tradeSetup = null;
      if (comp.signal !== 'NEUTRAL') {
        tradeSetup = TradeGen.generate(comp.signal, ind, smc, comp, tradeCapital, riskAmt, userLev);
      }
      // Detect what changed
      const changes = detectChanges(prevSetupRef.current, tradeSetup, prevCompositeRef.current, comp);
      if (changes.length > 0) {
        setSetupChanges(prev => [...changes, ...prev].slice(0, 20));
      }
      prevSetupRef.current = tradeSetup;
      prevCompositeRef.current = comp;
      setAllInd(ind); setAllSmc(smc); setTfScores(scores); setComposite(comp); setSetup(tradeSetup);
      setTicker(result.ticker);
      setLivePrice(+result.ticker.lastPrice);
      setLastRefresh(new Date());
      setLoading(false);
      setStatus('Ready');
      if (result.errs.length) setError('Partial: ' + result.errs.join(', '));
    } catch (e) {
      setError(e.message); setLoading(false); setStatus('Error');
    }
  }, [tradeCapital, riskAmt, userLev]);

  useEffect(() => { refresh(); const id = setInterval(refresh, REFRESH_MS); return () => clearInterval(id); }, [refresh]);

  // Recalculate setup when capital/risk changes (without refetching)
  useEffect(() => {
    if (composite.signal !== 'NEUTRAL' && Object.keys(allInd).length) {
      setSetup(TradeGen.generate(composite.signal, allInd, allSmc, composite, tradeCapital, riskAmt, userLev));
    }
  }, [tradeCapital, riskAmt, userLev]);

  // WebSocket
  useEffect(() => {
    if (loading) return;
    let ws;
    const connect = () => {
      ws = new WebSocket(DataService.getWsUrl());
      ws.onmessage = e => { try { setLivePrice(+JSON.parse(e.data).k.c); } catch {} };
      ws.onclose = () => setTimeout(connect, 5000);
      ws.onerror = () => ws.close();
      wsRef.current = ws;
    };
    connect();
    return () => { if (wsRef.current) wsRef.current.close(); };
  }, [loading]);

  // Auto-log setups to Signal Performance Log (only on genuine signal change)
  useEffect(() => {
    if (!setup) return;
    const key = `${setup.direction}_${composite?.signal}`;
    if (key === lastLoggedSignal.current) return; // skip if signal hasn't truly changed
    const added = SignalLog.logSetup(setup, composite);
    if (added) {
      lastLoggedSignal.current = key;
      setSignalLogData(SignalLog.getAll());
    }
  }, [setup?.direction, composite?.signal]);

  // Check signal outcomes on each data refresh (using 15m candles)
  useEffect(() => {
    const candles15m = allInd['15m']?.candles;
    if (!candles15m || candles15m.length < 2) return;
    const before = SignalLog.getAll();
    SignalLog.checkOutcomes(candles15m);
    const after = SignalLog.getAll();
    if (JSON.stringify(before) !== JSON.stringify(after)) setSignalLogData(after);
  }, [allInd['15m']?.candles?.length, lastRefresh]);

  const handleClearSignalLog = useCallback(() => { SignalLog.clear(); setSignalLogData([]); }, []);
  const handleImportSignalLog = useCallback(() => { setSignalLogData(SignalLog.getAll()); }, []);

  const change24h = ticker ? +ticker.priceChangePercent : null;

  if (loading) return (
    <div>
      <Header livePrice={null} change24h={null} lastRefresh={null} onRefresh={refresh} />
      <div className="loading pulse" style={{marginTop:60}}>{status}</div>
    </div>
  );

  return (
    <div>
      <Header livePrice={livePrice} change24h={change24h} lastRefresh={lastRefresh} onRefresh={refresh} />
      {error && <div className="error-box">{error}</div>}

      <div className="main-grid">
        {/* LEFT PANEL (desktop wrapper, unwraps on mobile) */}
        <div className="col-left">
          <div className="m-chart"><ChartPanel candles={allInd[selectedTF]?.candles} ind={allInd[selectedTF]} smc={allSmc[selectedTF]} setup={setup} tf={selectedTF} /></div>
          <div className="m-confluence"><ConfluenceMeter tfScores={tfScores} composite={composite} /></div>
          <div className="m-tf card">
            <div className="card-head" style={{cursor:'default'}}>
              <span>Timeframe Analysis <Tip k="tfAnalysis" /></span>
              <span className="muted" style={{fontSize:10}}>{allInd[selectedTF]?.candles?.length ?? 0} candles</span>
            </div>
            <div className="card-body">
              <div className="tabs">
                {TIMEFRAMES.map(tf => (
                  <div key={tf} className={`tab ${tf===selectedTF?'active':''}`} onClick={() => setSelectedTF(tf)}>
                    {TF_LABELS[tf]}
                    <div style={{fontSize:9,marginTop:1,color:tf===selectedTF?'rgba(255,255,255,0.7)':tfScores[tf]?.score>20?'var(--bull)':tfScores[tf]?.score<-20?'var(--bear)':'var(--muted)'}}>
                      {tfScores[tf] ? (tfScores[tf].score > 0 ? '+' : '') + tfScores[tf].score : '—'}
                    </div>
                  </div>
                ))}
              </div>
              <TFPanel tf={selectedTF} ind={allInd[selectedTF]} smc={allSmc[selectedTF]} />
            </div>
          </div>
          <div className="m-factors"><FactorDetail tfScores={tfScores} selectedTF={selectedTF} /></div>
        </div>

        {/* RIGHT PANEL (desktop wrapper, unwraps on mobile) */}
        <div className="col-right">
          <div className="m-summary"><ExecutiveSummary setup={setup} composite={composite} /></div>
          <div className="m-setup"><TradeSetupCard setup={setup} tradeCapital={tradeCapital} riskAmt={riskAmt} userLev={userLev} onCapitalChange={setTradeCapital} onRiskChange={setRiskAmt} onLevChange={setUserLev} composite={composite} setupChanges={setupChanges} /></div>
          <div className="m-entry"><EntryTiming setup={setup} /></div>
          <div className="m-journal"><TradeJournal trades={journalTrades} onTradesChange={updateJournal} setup={setup} composite={composite} /></div>
        </div>

        {/* BOTTOM PANEL */}
        <div className="m-history bottom-panel"><PriceHistoryChart allInd={allInd} /></div>
        <div className="m-tvChart bottom-panel"><TradingViewChart /></div>
        <div className="m-levels bottom-panel"><KeyLevelsPanel ind={allInd[selectedTF]} smc={allSmc[selectedTF]} /></div>
        <div className="m-siglog bottom-panel"><SignalLogPanel log={signalLogData} onClear={handleClearSignalLog} onImport={handleImportSignalLog} tradeCapital={tradeCapital} userLev={userLev} /></div>
      </div>

      {/* FOOTER */}
      <div className="footer" style={{textAlign:'center'}}>
        This tool is for educational and informational purposes only. It does not constitute financial advice.
        Cryptocurrency trading involves substantial risk of loss. Past performance of technical indicators does not guarantee future results.
        Never trade with money you cannot afford to lose. Always do your own research (DYOR).
      </div>
      <BackToTop />
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
